#!/home/champoll/Python/bin/python

"""
Takes two text files and aligns them letter by letter using diff.
Then edits the aligned file in the following way to conform to fnTBL's input format:

As we have told fnTBL in the file 'file.templ', our input consists of three columns:

<content of file.templ:> original guess => goldstandard

One column for the original, one for the most likely class (which is always the original letter),
one for the gold standard. No insertions or deletions are allowed. So this script does the
following:

f f        f f f
o o        o o o
u o        u u o      reduplicate the leftmost line (the original) and place it
           _ _ _      in the middle; also replace whitespace by 'blank' symbol "_"
p b   =>   p p b      in the middle
a a        a a a
r r        r r r

f f        f f
o o        o o
o o   =>   o ob       make insertion of a letter look like
b                     substitution of the previous letter by two letters
a a        a a        (or more in case of multiple insertions)
r r        r r

f f        f f
o o        o o
o o        o o
b     =>   b @        make deletion of a letter look like
a a        a a        substitution of this letter by the deletion symbol "@"
r r        r r


This script shouldn't be called directly by the user; it is called by the 'learn' script.

"""


import sys, commands, re, tempfile

blank = '_' # only one character! Must be the same as in other files.
deletion = '@' # only one character! Must be the same as in other files.

tmp = tempfile.gettempdir()+"/"

# hack to print something directly attached to previous
# output
def no_space_before(x):
    sys.stdout.softspace = 0
    return x

def remove_whitespace_at_end(string):
    return re.sub("\s+$", "", string)
rw = remove_whitespace_at_end

def insert_newlines_after_every_character(string):
    result = ''
    for character in string:
       result = result+character+'\n'
    return result
inaec = insert_newlines_after_every_character



# script starts here

if not len(sys.argv) == 3:
    print "usage: align original.txt truth.txt (shouldn't be used by you)"
    sys.exit(1)

file1 = sys.argv[1]
file2 = sys.argv[2]

temp1 = open(tmp+"__temp1__", "w")
temp2 = open(tmp+"__temp2__", "w")

# write each character on one line and make whitespace at end of lines uniform
for line in open(file1):
    temp1.write(inaec(rw(line)+' '))
temp1.close()

for line in open(file2):
    temp2.write(inaec(rw(line)+' '))
temp2.close()

# globally align both files and get rid of the column with characters like ">" and "|" that diff inserts
commands.getoutput("diff -y " + tmp + "__temp1__ " + tmp + "__temp2__ | cut -f 1,9 --output-delimiter=' ' - > " + tmp + "__temp3__")

# we now have a letter-by-letter alignment of the original and the goldstandard
# Now we need to edit it as described above, to conform to fnTBL's input format.

flag = False
# flag is true if we have just inserted a blank line.
# flag is checked before attaching any characters to the previous line
# so we don't accidentally attach to a blank line.
# (This will cause the character to be dropped instead of attaching it
# if some periods in the input aren't followed
# immediately by something else than a whitespace. For Middle French texts, this
# is never the case, so I won't bother with this problem here at the moment.)

for line in open(tmp + "__temp3__"):
    line = line.replace(' ', blank)                
    first_char = line[0]
    stripped = line[:-1]                           # get rid of newline character at end of line
    l = len(line)
    if not l == 3:                                 # if not character insertion here, we don't need the flag
        flag = False 
    if l == 1:                                     # an unchanged whitespace
       print '\n', blank, blank, blank,             
    elif l == 2:                                   # character deletion              
       print '\n', line[-2], line[-2], deletion,   # print the character twice and put deletion sign into the goldstandard column
    elif l == 3:                                   # character insertion
       if not flag == True:
          print no_space_before(line[-2]),         # attach the character to previous line
                                                   # else drop it
    elif l == 4:                                   # character replacement or no change
       print '\n', line[0], line[0], line[-2],
    else:
        raise ValueError, line                     # something went wrong with the diff/cut output
    if line.startswith('.'):                       # insert blank line after period
        print '\n',
        flag = True                                # warn the next cycle not to attach anything to the last line (blank line)


#cleanup
commands.getoutput("rm -f " + tmp + "__temp1__ "+tmp+"__temp2__ "+tmp+"__temp3__")



                                        




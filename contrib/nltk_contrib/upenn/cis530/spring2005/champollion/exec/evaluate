#!/home/champoll/Python/bin/python

"""
Simple evaluation tool based on global alignment.
The two input files are compared both word-based and letter-based using diff.
A result of 100% indicates that the files are identical.
usage: evaluate <testdata> <goldstandard>

"""

import sys, commands, tempfile, re
blank = '_' # has to be the same as in the other scripts
deletion = '@' # has to be the same as in the other scripts

tmp = tempfile.gettempdir()+'/'

# hack to print something directly attached to previous
# output
def no_space_before(x):
    sys.stdout.softspace = 0
    return x
ns = no_space_before

def remove_whitespace_at_end(string):
   return re.sub("\s+$", "", string)
rw = remove_whitespace_at_end

def insert_newlines_after_every_character(string):
    result = ''
    for character in string:
       result = result+character+'\n'
    return result
inaec = insert_newlines_after_every_character
                               

# script starts here

if not len(sys.argv) == 3:
        print 'usage: evaluate <testdata> <goldstandard>'
        sys.exit(1)

file1 = sys.argv[1]
file2 = sys.argv[2]



# word-based evaluation:
# tokenize testdata into words and punctuation
commands.getoutput(r'sed "s/[\.\,\:\;\!\?\/]/ &/g" ' +sys.argv[1]+ r' | tr -s " " "\n" > '+tmp+'__eval1w__')

# do the same with gold standard
commands.getoutput(r'sed "s/[\.\,\:\;\!\?\/]/ &/g" ' +sys.argv[2]+ r' | tr -s " " "\n" > '+tmp+'__eval2w__')

# character-based evaluation:

temp1 = open(tmp+"__eval1c__", "w")
temp2 = open(tmp+"__eval2c__", "w")

# write each character on one line and make whitespace at end of lines uniform
for line in open(file1):
    temp1.write(inaec(rw(line)+' '))
temp1.close()

for line in open(sys.argv[2]):
    temp2.write(inaec(rw(line)+' '))
temp2.close()

    
# use diff to align both files
commands.getoutput("diff -d --expand-tabs -y " + tmp + "__eval1w__ " + tmp + "__eval2w__ | cut -c 65 > " + tmp + "__eval3w__")
commands.getoutput("diff -d --expand-tabs -y " + tmp + "__eval1c__ " + tmp + "__eval2c__ | cut -c 65 > " + tmp + "__eval3c__")

# eval3c and eval3w contain only the symbols generated by diff: < for deletion, > for insertion, | for change,
# nothing for no change. All we need to do now is to count them.


for mode in ['character', 'word']:

    lines = 0
    substitutions = 0
    insertions = 0
    deletions = 0

    file = None
    if mode == 'word':
        file = open(tmp+"__eval3w__")
    else: # mode == 'character'
        file = open(tmp+"__eval3c__")
    for line in file:
        line = line[:-1] # get rid of newline
        lines += 1
        if line == '|':
            substitutions += 1
        elif line == '<':
            deletions += 1
        elif line == '>':
            insertions += 1

    linesF = float(lines) # this is so that division yields a float number

    changes = substitutions+insertions+deletions
    
    # percentages
    insertionsP = insertions*100/linesF
    deletionsP = deletions*100/linesF
    substitutionsP = substitutions*100/linesF
    changesP = changes*100/linesF
   
    accuracy = 100-changesP # The less changes, the higher this is.
    
    print 'Evaluation based on', mode, ns(':')

    # print everything with one decimal after the comma
    
    print 'Substitutions:', substitutions, 'out of', lines, '(%.1f' % substitutionsP, '%)'
    print 'Insertions:', insertions, 'out of', lines, '(%.1f' % insertionsP, '%)'
    print 'Deletions:', deletions, 'out of', lines, '(%.1f' % deletionsP, '%)'
    print 'Accuracy: %.1f' % accuracy, '%'
    print

# clean up
commands.getoutput('rm -f ' + tmp + '__eval1w__ ' + tmp + '__eval2w__ ' + tmp + '__eval3w__ ' + tmp + '__eval1c__ ' + tmp + '__eval2c__ ' + tmp + '__eval3c__ ')
                   
                 





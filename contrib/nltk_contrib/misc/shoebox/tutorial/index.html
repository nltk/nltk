<html>

<title>Handling Shoebox Dictionaries with the NLTK</title>

<body bgcolor="#FFFFFF">

<center>
<h2>Handling Shoebox Dictionaries with the Natural Language Toolkit</h2>
<h3>Stuart Robinson</h3>
</center>

<p>This tutorial introduces the Shoebox capabilities of the Natural Language Toolkit (NLTK) for Python. Here we concentrate on Shoebox dictionaries rather than interlinearized texts.</p>


<p><hr></p>


<a name="toc"></a>
<h4>Table of Contents</h4>

<ol>
  <li><a href="#section1">What is Shoebox?</a></li>
  <li><a href="#section2">How Does <tt>nltk.shoebox</tt> Work?</a></li>
  <li><a href="#section3">Some Case Studies</a></li>
    <ul>
      <li><a href="#casestudy1">Case 1: Formatting a Shoebox Lexicon for Display</a></li>
      <li><a href="#casestudy2">Case 2: Adding a Field to a Shoebox Lexicon Automatically</a></li>
      <li><a href="#casestudy3">Case 3: Filtering out Specific Fields in a Database</a></li>
      <li><a href="#casestudy4">Case 4: Automatically Extracting Minimal Pairs</a></li>
      <li><a href="#casestudy5">Case 5: Handling Entry Date Stamps</a></li>
      <li><a href="#casestudy6">Case 6: Guess Entry Template of Shoebox Dictionary Without Metadata</a></li>
      <li><a href="#casestudy7">Case 7: Validating Field Data Against Range Sets</a></li>
      <li><a href="#casestudy8">Case 8: Finding Entries that Conform to a Particular Profile</a></li>
<!--
      <li><a href="#casestudy8">Case 8: Automatic Analysis of Word Length and Photactics</a></li>
      <li><a href="#casestudy9">Case 9: Chaging the Order of Fields in an Entry</a></li>
      <li><a href="#casestudy10">Case 10: Breaking a Single Field into Many</a></li>
      <li><a href="#casestudy11">Case 11: Checking Fields for Uniqueness</a></li>
-->
    </ul>
  <li><a href="#section4">Conclusion</a></li>
  <li><a href="#links">Links</a></li>
</ol>


<p><hr></p>


<a name="section1"></a>
<h2>What is Shoebox?</h2> 

<p><a href="http://www.sil.org/computing/shoebox/">Shoebox</a> (and its latest incarnation, <a href="http://www.sil.org/computing/toolbox/">Toolbox</a>) is a computer program used by many linguists to handle fieldwork data. The description of the program provided on the Shoebox homepage sums it up nicely:

<p>"Shoebox is a computer program that helps field linguists and anthropologists integrate various kinds of text data: lexical, cultural, grammatical, etc. It has flexible options for sorting, selecting, and displaying data. It is especially useful for helping researchers build a dictionary as they use it to analyze and interlinearize text. The name Shoebox recalls the use of shoe boxes to hold note cards on which definitions of words were written in the days before researchers could use computers in the field."</p>

<p>A sample entry from a Shoebox dictionary of Rotokas (East Papuan, spoken on Bougainville) is provided below (taken from <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a>). Note the program displays the data in two columns: on the left are the field markers, which identify different data fields; on the right are the field values, which provide data for the fields identified by the markers on the left.</p>

<table border="1">
  <tr>
    <td><img src="images/screenshot-toolbox-lex-small-cropped.jpeg"></td>
  </tr>
</table>

<p>Alternate views of the data are possible. For example, below we find the same data displayed in three columns: on the left are the field markers and their descriptions; on the right are the field values (the actual data for the entry).</p>

<table border="1">
  <tr>
    <td><img src="images/screenshot-toolbox-lex2-small-cropped.jpeg"></td>
  </tr>
</table>

<p>It is possible to look at this data in its raw form using any word processor (e.g., Notepad, MS Word, etc.) or text editor (e.g., vi, emacs, etc.). Here is what the sample entry from it looks like:</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>\lx korau
\ps V.A
\ge clear
\ge unobstructed
\gp klia
\dt 14/Feb/2005
\cmt What is aue doing in the first example?
\ex Korauvira toupai aue evaoa.
\xp Diwais em i stap long ples klia.
\xe The trees are in the clearing.
\ex Ezra korauvira rutu toreparoi.
\xp Ezra i sanap long ples klia.
\xe Ezra is standing up in the clearing.
</pre></p></td></tr>
</table>

<p>This raw data is simply text and can be manipulated programmatically. Although Shoebox is a very full-featured program with good data analysis capabilities, there is no substitute for the power and flexibility of a bona fide programming language. Anyone who uses Shoebox has no doubt at some point wanted to perform some type of analysis but found the inherent capabilities of Shoebox inadequate for the task. For example, it would be quite difficult to query a Shoebox dictionary and obtain every example sentence for entries that, say, consist of four segments, begin with a particular consonant, end with a particular suffix, and belong to a particular part of speech. Yet the Shoebox functionality of the NLTK makes this possible---in fact, it makes the job fairly simple (see <a href="#casestudy8">Case 8</a> for an indication).</p>

<p>Here we will provide a tutorial on the manipulation of Shoebox dictionary files with the NLTK for Python. Although this tutorial does not require intimate knowledge of Shoebox, it is a good idea to familiarize yourself with at least the basics of the application. Fortunately, there is a good deal of documentation available (see <a href="#links">the links section</a>). (The programs are quite similar and most of the skills acquired on one transfer to the other. For this reason, all subsequent references to Shoebox can be assumed to apply equally well to Toolbox.)</p>



<!--
<h2>What is the NLTK?</h2>

<p>The <a href="http://freshmeat.net/projects/nltk/">Natural Language Toolkit (NLTK)</a> is, according to its authors, "a suite of program modules, data sets, tutorials, and exercises, covering symbolic and statistical natural language processing".  It is written in Python, an object-oriented scripting language, and, like Python, it is also free software in every sense of the term. You pay nothing for it and you are free to peek under the hood.</p>

<p>You can learn more about what the NLTK has to offer by consulting the <a href="http://nltk.sourceforge.net/docs.html">NLTK documentation</a>. In addition, there are also two academic articles on the NLTK (<a href="http://arxiv.org/abs/cs/0205028">1</a> | <a href="http://www.ldc.upenn.edu/sb/home/papers/nltk.pdf">2</a>) and a few tutorials, such as those on the NLTK site itself (<a href="http://nltk.sourceforge.net/tutorial/index.html">sourceforge.net</a>) or David Mertz's <a href="http://www-106.ibm.com/developerworks/linux/library/l-cpnltk.html">mini NLTK tutorial</a>. You will first need to install the NLTK. First, <a href="http://sourceforge.net/project/showfiles.php?group_id=30982&amp;package_id=23005">download the required files for the NLTK</a>. The NLTK is divided into three modules. It's the NLTK proper that you should install. The modules nltk-data and nltk-contrib can be ignored for now. After you <a href="http://nltk.sourceforge.net/install.html">follow the installation instructions for the NLTK</a>, you can begin to familiarize yourself with its contents.</p>
-->



<!-- HOW DOES NLTK.SHOEBOX WORK? -->
<a name="section2"></a>
<h2>How Does <tt>nltk.shoebox</tt> Work?</h2>

<p>Let's begin by looking at how <tt>nltk.shoebox</tt> is organized. Within <tt>nltk.shoebox</tt>, there are two main modules: standardformat.py and shoebox.py. The standardformat modules supplies most of the low-level functions for dealing with files in standard format (which in theory encompasses more than Shoebox files). The shoebox modules handles a good deal more, providing functionality for handling various aspects of standard format files that are specific to the Shoebox program. We will look at each in turn.</p>



<h3>Standard Format</h3>

<p>The first is a module that provides functionality for handling Standard Format, the file format used by Shoebox. Standard format is not well described (and is arguably rendered obsolete by other formats, such as XML). It consists of a collection of entries, which are generally separated from one another by double carriage returns. Technically, however, what defines the beginning of an entry is a particular field, referred to as the <b>head field</b>.</p>

<p>A sample entry from a Frisian Shoebox dictionary is provided below:</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
\fri do
\ps Pron
\g you
\eng you
</pre><td></tr>
</table>

<p>It is broken down into its constituent parts here (the first field, <tt>\fri</tt>, is the head field):</p>

<table border="1">
  <tr>
    <td><b>Field</b></td>
    <td><b>Field Marker</b></td>
    <td><b>Field Value</b></td>
  </tr>
  <tr>
    <td>1</td>
    <td><pre>\fri</pre></td>
    <td><pre>do</pre></td>
  </tr>
  <tr>
    <td>2</td>
    <td><pre>\ps</pre></td>
    <td><pre>Pron</pre></td>
  </tr>
  <tr>
    <td>3</td>
    <td><pre>\g</pre></td>
    <td><pre>you</pre></td>
  </tr>
  <tr>
    <td>4</td>
    <td><pre>\eng</pre></td>
    <td><pre>you</pre></td>
  </tr>
</table>

<p>Note that the field marker occurs at the beginning of a line and is preceded by a backslash and that the field value is separated from the field marker by a single space mark. The following is assumed to be true of standard format:</p>

<ol>
  <li>Field Marker:
    <ol type="a">
      <li>occurs at the beginning of a line</li>
      <li>starts with a single backslash</li>
      <li>first character after backslash is alphabetic</li>
      <li>cannot contain whitespace</li>
      <li>second and subsequent characters can be alphanumeric, an underscore (_), or dash (-)</li>
      <li>is separated from associated field data by a single space</li>
    </ol>
  </li>
  <li>Field Data:
    <ol type="a">
      <li>unrestricted text</li>
      <li>can include carriage returns</li>
      <li>cannot contain a line-inital backslash</li>
    </ol>
  </li>
</ol>

<p>As is the case with XML, it is useful to distinguish between two kinds of Shoebox data files:

<ul>
  <li><b>well-formed</b> conforms to Standard Format</li>
  <li><b>valid</b> well-formed and consistent with metadata</li>
</ul>

<p>(Note: There are some special field markers used in metadata files that violate the above-given rules concerning the initial-character of the field marker--for example, <tt>\+mkrset</tt> and <tt>\-mkrset</tt>.)</p>

<p>Some examples of well-formed and ill-formed Shoebox data are provided below:</p>

<table>
  <tr>
    <td><b>Well-Formed</b></td>
  </tr>
  <tr>
    <td>
      <table>
        <tr>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\ref orang
\ps N
\ge person
</pre></td>
          <td>&nbsp;</td>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\ref orang
\ps N
\nt
\ge person
</pre></td>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\ref orang
\ps N
\nt

\ge person
</pre></td>
          <td>&nbsp;</td>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\ref orang
\ps N
\ge person
\ge people
</pre></td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td><b>Ill-Formed</b></td>
  </tr>
  <tr>
      <table>
        <tr>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\ref orang \ps N \ge person
</pre></td>
          <td>&nbsp;</td>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\1 orang
\2 N
\3
\4 person
</pre></td>
          <td>&nbsp;</td>
          <td bgcolor="#CCFFFF" valign="top"><pre>
\ref orang \
\ge person
\ge people
</pre></td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<p>Well-formedness is therefore a necessary (but not sufficient) condition for validity.</p>



<h3>Shoebox</h3>

<p>Although most users interact with only a few Shoebox files (typically, only the dictionary file and interlinearized texts), many more are generated by the program. These files are normally modified from within Shoebox, using its handy graphical interface, but they can also be directly edited. However, this should be done with caution, since minor changes can have dramatic effects. We recommend that changes be made to copies of files and not to the originals. This significantly reduces the likelihood of irretrievable errors that lead to data loss.</p>

<p>To understand a little better what goes on under the hood, we will look at the files from <tt>Samples/Frisian1/</tt>.</p>

<table cellspacing="2" border="1">
  <tr>
    <td><b>Type</b></td>
    <td><b>File</b></td>
    <td></td>
    <td><b>Description</b></td>
  </tr>
  <tr>
    <td>Metadata</t>
    <td>Fri.prj</td>
    <td></td>
    <td>Frisian Project File</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>Default.lng<br>Frisian.lng</td>
    <td></td>
    <td>Language encoding files</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>FrisianD.typ</td>
    <td></td>
    <td>Metadata for Frisian dictionary</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>FrisianT.typ</td>
    <td></td>
    <td>Metadata for Frisian texts</td>
  </tr>
  <tr>
    <td>Data</t>
    <td>FriRt.dic</td>
    <td></td>
    <td>Frisian dictionary</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>FriSampl.txt</td>
    <td></td>
    <td>A sample interlinear text in Frisian</td>
  </tr>
</table>

<p>It is useful to distinguish between two types of files:</p>

<ul>
  <li><b>data files</b>, which contain actual language data (lexicon, text, etc.)</li>
  <li><b>metadata files</b>, which contain information about the language data (rather than the actual data itself)
</ul>

<p>Data files are directly modified by the user through the Shoebox program, whereas metadata files are modified indirectly, by the program itself.</p>

<p>As an illustration, consider a particular entry from the Frisian dictionary, the one for the indefinite article <i>a</i>. It has four field markers: <tt>eng</tt>, <tt>fri</tt>, <tt>g</tt>, and <tt>ps</tt>. Information about these field markers is found in <tt>FrisianD.typ</tt>. Excerpts from this file are provided below:</p>

<table border="1">
  <tr>
    <td><b>Field Markers</b></td>
    <td><tt>eng</tt></td>
    <td><tt>fri</tt></td>
    <td><tt>g</tt></td>
    <td><tt>ps</tt></td>
  </tr>
  <tr>
    <td><b>Metadata Definition</b></td>
    <td valign="top"><pre>\+mkr eng
\nam English
\lng Default
\mkrOverThis fri
\-mkr</pre></td>
    <td valign="top"><pre>\+mkr fri
\nam Frisian Word
\lng Frisian
\-mkr</pre></td>
    <td valign="top"><pre>\+mkr g
\nam Gloss
\lng Default
\mkrOverThis fri
\-mkr</pre></td>
    <td valign="top"><pre>\+mkr ps
\nam Part of Speech
\lng Default
\mkrOverThis fri
\-mkr</pre></td>
  </tr>
</table>

<p>When metadata of this sort is available, it is possible to validate Shoebox data against it in order to ensure that the data is valid. In one of the cases examined below (<a href="#casestudy8">Case 8: Validating Field Data Against Range Sets</a>), we will see how the fields of a Shoebox dictionary can be validated against metadata to ensure that all of the field values for a particular field marker belong to a fixed list of possible values.</p>



<!-- PARSING -->
<a name="parsingandvalidation"></a>
<h3>Parsing and Validation</h3>

<p>There are 3 ways of parsing a Shoebox dictionary file into entries and their associated fields:</p>


<table border="1">
  <tr>
    <td><b>Available Information</b></td>
    <td><b>Description</b></td>
    <td><b>Can be Parsed?</b></td>
    <td><b>Can be Validated?</b></td>
  </tr>
  <tr>
    <td>No Metadata</td>
    <td>If no metadata is available, it is assumed that the first field of the first entry encountered is the head field.</td>
    <td>Yes</td>
    <td>No</td>
  </tr>
  <tr>
    <td>Head Field Known</td>
    <td>If the head field marker is known, it is therefore possible to handle properly multiline fields.</td>
    <td>Yes</td>
    <td>No</td>
  </tr>
  <tr>
    <td>Shoebox Metadata</td>
    <td>With the full metadata available (i.e., *.typ file), it is possible to parse the data file and ensure that the contents conform to the metadata constraints.</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
</table>

<!--<p><a href="conundrum.html">Comments on Shoebox Parsing</a></p>-->

<p>When a full metadata description of a Shoebox file is available, the Shoebox parser can validate its contents against their metadata specification. All validation errors extend from the class ShoeboxValidationError. The following validation errors are recognized:</p>

<table border="1">
  <tr>
    <td colspan="2"><b>Error Type</b></td>
    <td><b>Description</b></td>
  </tr>
  <tr>
    <td colspan="2">BadMetadataFile</td>
    <td>Something is wrong with the metadata file and it cannot be parsed.</td>
  </tr>
  <tr>
    <td colspan="2">NoMetadataFound</td>
    <td>No metadata file has been supplied even though one is required.</td>
  </tr>
  <tr>
    <td rowspan="4">BadFieldValue</td>
    <td>ValueOutsideRangeSet</td>
    <td>The value falls outside of the fixed set specified for a particular field.</td>
  </tr>
  <tr>
    <td>NoWordWrap</td>
    <td>The value of the field has a carriage return despite being specified for no word wrap.</td>
  </tr>
  <tr>
    <td>EmptyValue</td>
    <td>No value is provided for a field that requires one.</td>
  </tr>
  <tr>
    <td>SingleWord</td>
    <td>The value of a field consists of multiple words despite being specified for only a single word.</td>
  </tr>
</table>



<!-- SOME CASE STUDIES -->
<a name="section3"></a>
<h2>Some Case Studies</h2>

<p>For these demonstrations of <tt>nltk.shoebox</tt> functionality, we will manipulate some sample Shoebox files (in the folder <tt>Samples</tt>). Because the sample files can be useful when learning how to use Shoebox, most users prefer to keep an unmodified version of them. Therefore, we recommend making a backup of these files before trying the scripts below.</p>



<a name="casestudy1"></a>
<h3>Case 1: Formatting a Shoebox Lexicon for Display</h3>

<p>Raw Shoebox data isn't very easy to read. It's therefore useful to be able to reformat a Shoebox dictionary file according to your wishes. Although Shoebox has in-built facilities for producing formatted dictionaries, they do not rival the possibilities provided by the NLTK. Here we will stick to the basics for the sake of illustration and show how a minimally formated plain text version of a Shoebox dictionary can be produced using the NLTK.</p>

<p>The script <a href="../bin/reformat-dict.py">reformat-dict.py</a> does the job. It is run as follows:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/reformat-dict.py samples/Rotokas/ROTRT.DIC
</pre></td></tr>
</table>

<p>The script is quite simple. It simply parses a Shoebox dictionary file, goes through each entry, retrieves selected fields, and then prints them out with some bare bones formatting: the lexeme, the part-of-speech in parentheses, and the English translation in single quotes. Note that the translation is created dynamically, but first checking whether the field <tt>eng</tt> exists for an entry, and then falling back on <tt>ge</tt> if it does not.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def main() :
    try :
        filepath = sys.argv[1]
    except :
        sys.stderr.write("%s <FILEPATH>" % sys.argv[0])
        sys.exit(0)        
    fp = StandardFormatFileParser(filepath)
    sff = fp.parse()
    print sff.getHeader()
    for e in sff.getEntries() :
        lex   = e.getHeadField()[1]
        pos   = e.getFieldValuesByFieldMarkerAsString("ps")
        gloss = e.getFieldValuesByFieldMarkerAsString("ge")
        eng   = e.getFieldValuesByFieldMarkerAsString("eng", "/")
        if eng :
            print "%s (%s) '%s'" % (lex, pos, eng)
        else :
            print "%s (%s) '%s'" % (lex, pos, gloss)
</pre></td></tr>
</table>

<p>There are two different methods of the Entry class that can be used to obtain specific fields of an entry: <tt>getFieldValuesByFieldMarker()</tt> and <tt>getFieldValuesByFieldMarkerAsString()</tt>. The method <tt>getFieldValuesByFieldMarker()</tt> returns all of the field values for a given field marker as a list. If the field is not found, the list will be empty. Otherwise, the number of items will equal the number of times the field is found in the entry. Because of the possibility of obtaining a <tt>None</tt> value, it is sometimes preferable to use the method <tt>getFieldValueByFieldMarkerAsString()</tt>, which always returns a string. If the specified field is not found, a blank string is returned (as opposed to the value <tt>None</tt>). If the specified field is non-unique, the fields are combined into a single string. The default separator in the returned string are space marks, but an alternative separator can be specified as a second argument to the method. Calling <tt>getFieldValuesByFieldMarker("eng", "/")</tt> returns all of the <tt>\eng</tt> fields as a single string separated by slashes.</p>



<a name="casestudy2"></a>
<h3>Case 2: Adding a Field to a Shoebox Lexicon Automatically</h3>

<p>For this case study, we will manipulate the Frisian dictionary that comes with Shoebox. Our goal is to add to each entry in the lexicon a field that provides the CV skeleton for that entry. For example, the CV skeleton for <i>brek</i> is <tt>CCVC</tt> and for <i>bikwaam</i>, <tt>CVCCVVC</tt>. The Shoebox functionality of the NLTK significantly simplifies the job of going through each entry and computings its CV skeleton, as can be seen by <a href="../bin/add-cv-skeleton.py">add-cv-skeleton.py</a>. To see the script in operation, we can run it on one of the Frisian dictionaries that comes with Shoebox as part of a sample project (<a href="../samples/Frisian1/FriRt.dic">FriRt.dic</a>):</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/add-cv-skeleton.py samples/Frisian1/FriRt.dic
</pre></td></tr>
</table>

<p>Because the scripts writes to standard output, its output can be redirected to a file in order to create a new version of the processed Shoebox dictionary file, as illustrated below:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/add-cv-skeleton.py samples/Frisian1/FriRt.dic > samples/Frisian1/FriRt-new.dic
</pre></td></tr>
</table>

<p>When the new version of the lexicon is opened again with Shoebox, the only change is the inclusion of a <tt>cv</tt> field in every entry, as can be seen in the following before-and-after screenshots:</p>

<table border="0">
  <tr>
    <td><b>Before</b></td>
    <td>&nbsp;</td>
    <td><b>After</b></td>
  </tr>
  <tr>
    <td><img src="images/add-cv-skeleton-before.jpeg"></td>
    <td>&nbsp;</td>
    <td><img src="images/add-cv-skeleton-after.jpeg"></td>
  </tr>
</table>

<p>Here's how the script works. First, the script imports two classes from the StandardFormat module: the StandardFormatFileParser and the StandardFormatFile. The former builds the latter from a Shoebox dictionary file.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
from shoebox.standardformat import StandardFormatFileParser
</pre><td></tr>
</table>

<p>It then defines three functions, <tt>handle_options()</tt>, <tt>cv()</tt> and <tt>main()</tt>. The function <tt>cv()</tt> is a very simple function that takes a lexical entry as input and returns its CV skeleton. It does this by using regular expressions to replace consonants with <tt>C</tt> and vowels with <tt>V</tt>.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def cv(s):
    s = s.lower()
    s = re.sub(r'[^a-z]',     r'-', s)
    s = re.sub(r'[^aeiou\-]', r'C', s)
    s = re.sub(r'[aeiou]',    r'V', s)
    return (s)
</pre><td></tr>
</table>

<p>The function <tt>main()</tt> does the major work. First, the path to the Shoebox dictionary file is obtained as a command line argument, and a usage message is printed if one is not supplied.</tt>. Second, a StandardFormatFileParser object is created and the <tt>parse()</tt> method is called to obtain a StandardFormatFile object. The header information of the dictionary is printed out. This header information is crucial since Shoebox will not recognize the dictionary without it. Here's what it looks like:</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
\_sh v3.0  400  Frisian Dictionary
</pre><td></tr>
</table>

<p>The entries within the dictionary are next obtained by calling the <tt>getEntries()</tt> method, which produces a list of Entry objects. These are then iterated over and the head field of each is retrieved by calling the <tt>getHeadField()</tt> method. The CV skeleton is constructed using the <tt>cv()</tt> function and added back to the entry with the <tt>addField()</tt> method. The entry is then printed by relying upon the <tt>__str__</tt> method of the Entry class for formatting.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def main() :
    try :
        filepath = sys.argv[1]
    except :
        sys.stderr.write("%s -f <FILEPATH>\n" % sys.argv[0])
        sys.exit(0)
        
    fp = StandardFormatFileParser(filepath)
    sff = fp.parse()

    print sff.getHeader()
    for entry in sff.getEntries() :
        headField = entry.getHeadField()
        frisian = headField[1]
        entry.addField("cv", cv(frisian))
        print entry
</pre><td></tr>
</table>



<a name="casestudy3"></a>
<h3>Case 3: Filtering out Specific Fields in a Database</h3>

<p>It is sometimes useful to be able to remove extraneous fields from a dictionary. The script <a href="../bin/filter-fields.py">filter-fields.py</a> prints out the contents of a Shoebox dictionary, omitting the field specified by the user on the command-line. To see how it works, we will run the filter on the Rotokas dictionary <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a>, filtering out the date field (<tt>\dt</tt>), as follows:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/filter-fields.py -f dt samples/Rotokas/ROTRT.DIC
</pre></td></tr>
</table>

<p>In order to filter out multiple fields, the script can be run multiple times, as illustrated below:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/filter-fields.py -f dt  samples/Rotokas/ROTRT.DIC > /tmp/foo1.txt
$ python bin/filter-fields.py -f cmt /tmp/foo1.txt             > /tmp/foo2.txt
$ python bin/filter-fields.py -f nt  /tmp/foo2.txt             > samples/Rotokas/ROTRT-FILTERED.DIC
</pre></td></tr>
</table>

<p>To understand how the script works, we'll look at the <tt>main()</tt> function, provided below:</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def main() :
    fn, field2Filter = handle_options()
    fp = StandardFormatFileParser(fn)
    sff = fp.parse()
    print sff.getHeader()
    for e in sff.getEntries() :
        e.removeField(field2Filter)
        print e
</pre></td></tr>
</table>

<p>The function <tt>handle_options()</tt> first obtains from the command-line the path to a Shoebox file and the field to be filtered. Then the Shoebox dictionary is parsed into a StandardFormatFile object. A list of entries is obtained using the <tt>getEntries()</tt> method and then iterated over. From each entry, the following fields are obtained:

<ul>
  <li>the lexical entry (the head field)</li>
  <li>the part-of-speech</li>
  <li>the gloss</li>
  <li>any and all English translations</li>
</ul>



<a name="casestudy4"></a>
<h3>Case 4: Automatically Extracting Minimal Pairs</h3>

<p>When studying the phonology of a language, it is useful to have a list of <b>minimal pairs</b>---which for our purposes we will define as a pair of words of the same length (i.e., identical number of characters) that differ from one another by a single character (e.g., <i>bill</i> and <i>pill</i> in English). It is relatively easy to extract minimal pairs automatically from word lists, provided that the orthography in the word list is phonemic (i.e., characters represent phonemes) and that there is a one-to-one relationship between characters and phonemes (i.e., no digraphs).</p>

<p>The script <a href="../bin/find-min-pairs.py">find-min-pairs.py</a> will find all minimal pairs within a Shoebox dictionary. Below we see the first few lines of output obtained by running it on a Shoeobox dictionary file for Rotokas (<a href="">ROTRT.DIC</a>):</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-min-pairs.py samples/Rotokas/ROTRT.DIC
a/e:kaa/kae
a/u:kaa/kau
a/e:kaa/kea
a/o:kaa/koa
a/e:kaa/kae
...
</pre></td></tr>
</table>

<p>To see the total number of minimal pairs obtained, we can pipe the output to the Unix utility <tt>wc</tt> with the <tt>-l</tt> flag so that the number of lines is counted:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-min-pairs.py samples/Rotokas/ROTRT.DIC | wc -l
456
</pre></td></tr>
</table>

<p>Here's how the script works. With a monographic, phonemic orthography, finding minimal pairs is a fairly trivial task. One simple algorithm for identifying minimal pairs goes as follows: The length of every word in a Shoebox dictionary is determined. Every word is compared to every other word of the same length. (There is no point in examining words of different lengths, since they cannot be a minimal pair). Words of identical length are lined up and each segment in the word is compared one by one, in sequential order. A minimal pair is then simply a pair of identical-length words that differ only by one segment. Consider a pair of words like <i>mint</i> and <i>lint</i>:</p>

<table border="1">
<tr><td><table cellpadding="2" cellspacing="2">
  <tr>
    <td><b>Index</b></td>
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
  </tr>
  <tr>
    <td><b>Letters</b></td>
    <td><tt>m</tt></td>
    <td><tt>i</tt></td>
    <td><tt>n</tt></td>
    <td><tt>t</tt></td>
  </tr>
  <tr>
    <td></td>
    <td><tt>l</tt></td>
    <td><tt>i</tt></td>
    <td><tt>n</tt></td>
    <td><tt>t</tt></td>
  </tr>
  <tr>
    <td><b>Same?</b></td>
    <td><tt>N</tt></td>
    <td><tt>Y</tt></td>
    <td><tt>Y</tt></td>
    <td><tt>Y</tt></td>
  </tr>
</table></td></tr>
</table>

<!--<p>The only problem with this approach is that when you compare every word in a list to every other, the number of comparisons required ends up being very large, since the number of comparisons is exponentially related to the number of words in the list (if the number of words in a word list is <i>n</i>, then the number of comparison is <i>n<sup>2</sup></i>). Therefore, the speed up the program, we first divide up the list according to word length and only compare words of similar length.</p>-->

<p>Here we provide a simple script that takes a Shoebox dictionary and extracts all of the minimal pairs in it: <a href="../bin/find-min-pairs.py">find-min-pairs.py</a>. The first part of the program uses the NLTK's Shoebox functionality to extract all of the words from the Shoebox dictionary.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def extractWords(filepath) :
    words = []
    sffp = StandardFormatFileParser(filepath)
    sff = sffp.parse()
    for e in sff.getEntries() :
        hf = e.getHeadField()
        words.append(hf[1])
    return words
</pre></td></tr>
</table>

<p>The words are then fed into a function that classifies them according to length, returning a dictionary in which a key-value pair is a particular word length and a list of words of that length.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def sortWordsByLength(words) :
    wordLengths = {}
    for w in words :
        wl = len(w)
        if not wordLengths.has_key(wl) :
            wordLengths[wl] = []
        wordLengths[wl].append(w)
    return wordLengths
</pre></td></tr>
</table>

<p>The dictionary of word lengths is then passed to the function <tt>findMinPairs()</tt>, which goes through words of identical length and finds any minimal pairs among them.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def findMinPairs(wordsByLength) :
    for l in wordsByLength.keys() :
        words1 = wordsByLength[l]
        words2 = wordsByLength[l]
        for w1 in words1 :
            for w2 in words2 :
                i = 0
                diffCount = 0
                diffChar1 = ''
                diffChar2 = ''
                while i < l :
                    if not w1[i] == w2[i] :
                        diffCount = diffCount + 1
                        diffChar1 = w1[i]
                        diffChar2 = w2[i]
                    i = i + 1
                    if diffCount > 1 :
                        continue
                if diffCount == 1 :
                    print "%s/%s:%s/%s" % (diffChar1, diffChar2, w1, w2)
            words1.remove(w1)
</pre></td></tr>
</table>



<a name="casestudy5"></a>
<h3>Case 5: Handling Entry Date Stamps</h3>

<p>If properly configured (see <a href="http://www.sil.org/computing/shoebox/tips/DateStamp.html">date stamps documentation</a>), Shoebox will automatically update the date field of a dictionary entery whenever that entry is modified (i.e., created or edited). We will refer to this date field as a <b>date stamp</b>. Date stamps are a very useful feature with a number of possible applications, but one obvious benefit is that they provide an inherent log of activity in a database. This can be quite useful if one user wishes to review the changes made to a database by another user, as might be the case when a Shoebox dictionary is shared by multiple parties. (Shoebox makes few provisions for multi-user set-ups.)</p>



<h4>Obtaining a Log of Activity on a Shoebox Database</h4>

<p>By looking at date stamps, it is possible to determine quickly the general patterns of activity on a database. Essentially, this means being able to answer quickly and easily questions such as the following: When was the database originally created? When was it first modified? When was it last modified? These questions can be answered using the script <a href="../bin/list-modified-dates.py">list-modified-dates.py</a>, which takes a Shoebox dictionary and provides a summary of the activity on a dictionary file by examining its entry date stamps. Its use with <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a> is illustrated below:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/list-modified-dates.py samples/Rotokas/ROTRT.DIC
2003 May    2 00%
2004 Jan    1 00%
2004 Feb   64 07%
2004 May    1 00%
2004 Jul   14 01%
2004 Aug    4 00%
2004 Sep   49 05%
2004 Oct    5 00%
2004 Nov    5 00%
2004 Dec  151 18%
2005 Jan  123 14%
2005 Feb  307 36%
2005 Mar   37 04%
2005 Apr   29 03%
2005 May   46 05%
</pre></td></tr>
</table>

<p>If the flag <tt>-g</tt> is provided, the output takes the form of a histogram:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/list-modified-dates.py -g samples/Rotokas/ROTRT.DIC
2003 May    2
2004 Jan    1
2004 Feb   64 *******
2004 May    1
2004 Jul   14 *
2004 Aug    4
2004 Sep   49 *****
2004 Oct    5
2004 Nov    5
2004 Dec  151 ******************
2005 Jan  123 **************
2005 Feb  307 ************************************
2005 Mar   37 ****
2005 Apr   29 ***
2005 May   46 *****
</pre></td></tr>
</table>

<p>The output of the program is a breakdown of the number of entries modified during a particular month of a particular year. In the example provided, we see that the entries in the dictionary were modified between 2003 and 2005 with a peak of activity between December 2004 and Feb 2005.</p>

<p>The Shoebox functionality of the NLTK greatly simplifies this programming task. In fact, the only real complication is the handling of dates and times in Python (see <a href="http://docs.python.org/lib/module-datetime.html">python.org's datetime documentation</a>). To understand how the script works, we will first look at the function <tt>main()</tt>, which calls a number of custom functions.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def main() :
    fn, histogram = handle_options()
    d = process_file(fn)
    print_results(d, histogram)
</pre></td></tr>
</table>

<p>First, the file to be processed and any options are obtained from the command line. The main option is <tt>-g</tt> or <tt>--histogram</tt>, which determines the nature of the output. If the flag is provided, the output takes the form of a histogram; otherwise, percentages are provided. Second, the file is parsed and the date fields of every entry is put into a dictionary, where each key is a particular dates whose associated value is a count of the number of entries modified on that date. Finally, the contents of this dictionary are printed out for display by <tt>print_results()</tt>.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def print_results(d, histogram) :
    total = 0
    for yr in d.keys() :
        months = d[yr].keys()
        for m in months :
            dateList = d[yr][m]
            count = len(dateList)
            total = total + count
    
    for yr in d.keys() :
        months = d[yr].keys()
        months.sort()
        for m in months :
            dateList = d[yr][m]
            count = len(dateList)
            if histogram :
                print "%s %s %04s %s" % (yr, format_month(m), count, ((count * 100 / total) * "*") )                
            else :
                print "%s %s %04s %02d%%" % (yr, format_month(m), count, (count * 100.0 / total) )
</pre></td></tr>
</table>

<p>Note that for display the months are converted from integers to strings for the sake of readability. This is done using a custom fuction <tt>format_month(intMonth)</tt>. It would also be possible to do this conversion with built-in functionality from the Python standard library. We leave this as an exercise for the reader.</p>



<h4>Finding All Entries Modified During a Particular Time Range</h4>

<p>Once we have a general idea of when a database has been modified, it would be useful to be able to view only the entries within a particular time range. The script <a href="../bin/find-modified-entries.py">find-modified-entries.py</a> takes a Shoebox dictionary and lists all entries modified within a time range specified by the user using command-line options. The logic of the script is reasonably straightforward:</p>

<ul>
  <li>if the user provides a start and end date, all entries modified on those dates or between them will be listed</li>
  <li>if the user provides only a start date, all entries modified on that date and after it will be listed</li>
  <li>if the user provides only an end date, all entries modified on that date and before it will be listed</li>
</ul>

<p>Here we illustrate its use with <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a>, specifying only the start date (May 30th, 2005), which means that every entry modifed on or after the start date will be printed out. In this case, this amounts to only two entries.</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-modified-entries.py -s 30/May/2005 samples/Rotokas/ROTRT.DIC
kou [V.B] 'lay egg defecate' (30/May/2005)
karu [V.B] 'open unlock untie unhook' (30/May/2005)
</pre></td></tr>
</table>

<p>To obtain every day on or before the same start date, the script can be run specifying only the end date, which means that every entry modified on or before the end will be printed out. (Note that the date range is inclusive. To prevent the two entries with the date stamp <tt>30/May/2005</tt> from being printed out, the specified date is one day prior---that is, May 29th, 2005 rather than May 30th, 2005)</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-modified-entries.py -e 29/May/2005 samples/Rotokas/ROTRT.DIC
kasiarao [N.F] 'limbum' (15/Sep/2004)
kerikerisi [V.B] 'evaluate judge carefully' (14/Feb/2005)
karuvira [ADV] 'open' (12/Feb/2005)
kogo [V.B] 'cut chop' (01/Dec/2004)
koroto [V.B] 'meet together' (02/Dec/2004)
...
</pre></td></tr>
</table>

<p>If the user specifies a date on the command-line in the wrong format, an error message is raised, as illustrated below:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-modified-entries.py -s 30/5/2005 samples/Rotokas/ROTRT.DIC
Traceback (most recent call last):
  File "bin/find-modified-entries.py", line 95, in ?
    main()
  File "bin/find-modified-entries.py", line 89, in main
    startDate = string_to_datetime(startDateStr, dateFormat)
  File "bin/find-modified-entries.py", line 43, in string_to_datetime
    epochSecs = time.mktime(time.strptime(dateString, dateFormat))
  File "/usr/local/lib/python2.3/_strptime.py", line 424, in strptime
    raise ValueError("time data did not match format:  data=%s  fmt=%s" %
ValueError: time data did not match format:  data=30/5/2005  fmt=%d/%b/%Y
</pre></td></tr>
</table>

<p>The problem is that the script expects dates to be formatted as a one- or two-digit day, a three-letter month, and a four-digit year (separated by slahes), but the user-specified date does not conform to that format. It gives an integer for the month rather than a three-letter code (that is, <tt>5</tt> rather than <tt>May</tt>). (It is possible to use different date formats, and the script provides for this possibility with the option <tt>-f</tt>.)</p>

<p>In broad strokes, the script works by parsing the Shoebox dictionary into a StandardFormatFile object, iterating over its entries, and checking whether the entry's date stamp belongs to the time range defined by the user. We can see how this is done by first looking at the function <tt>main()</tt>.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def main() :
    fn, startDateStr, endDateStr, userDateFormat = handle_options()
    dateFormat = "%d/%b/%Y"
    if userDateFormat :
        dateFormat = userDateFormat
    startDate = string_to_datetime(startDateStr, dateFormat)
    endDate = string_to_datetime(endDateStr, dateFormat)
    d = process_file(fn, startDate, endDate, dateFormat)
    print_results(d)
    return
</pre></td></tr>
</table>

<p>In the function <tt>main()</tt>, numerous options are obtained from the command-line with the <tt>handle_options()</tt> function. The custom date format is overriden if one is provided by the user. The date format is then used to parse the start and end dates into <tt>datetime</tt> objects. These are then passed to the function <tt>process_file</tt>. Note that the date format is also passed, since the script assumes that the same date format used to parse the user-specified dates will also be used to parse the dictionary's date stamps.</p>
    
<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def process_file(fn, startDate, endDate, dateFormat) :
    d = {}
    fp = StandardFormatFileParser(fn)
    sff = fp.parse()
    for e in sff.getEntries() :
        lexeme = e.getHeadField()[1]
        modDateStr = e.getFieldValuesByFieldMarkerAsString(FM_DATE)
        modDate = string_to_datetime(modDateStr, dateFormat)
        if modDate and in_time_range(startDate, endDate, modDate) :
            d[lexeme] = e
    return d
</pre></td></tr>
</table>

<p>The main work is done by the function <tt>in_time_range()</tt>, which takes three dates---the start date, the end date, and the date stamp of an entry---and determines whether the entry's date stamp falls within the date range defined by the start and end date.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def in_time_range(startDate, endDate, modDate) :
    if ( startDate and endDate ) and ( modDate >= startDate and modDate <= endDate ) :
        return True
    elif ( startDate and not endDate ) and ( modDate >= startDate ) :
        return True
    elif ( endDate and not startDate ) and ( modDate <= endDate ) : 
        return True
    else :
        return False
</pre></td></tr>
</table>

<p> If the date stamp of an entry does fall within the desired date range, the entry is added to a dictionary, which is then passed to the function <tt>print_results()</tt>, which prints out all of the entries in the dictionary with minimal formatting.</p>



<a name="casestudy6"></a>
<h3>Case 6: Guess Entry Template of Shoebox Dictionary Without Metadata</h3>

<p>If you work with Shoebox data, it's fairly likely that at some point you will come across a Shoebox dictionary by itself without any of the supporting metadata (language definitions, field marker definitions, etc.). In such a scenario, it is useful to be able to eyeball the data in order to learn more about the template used for entries. The idea is to query the database structure implicit in the dictionary by asking questions of the following sort: Which elements are obligatory? Which are optional? What are the dependencies?</p>

<p>Here we will present a short script, <a href="../bin/query-template-structure.py">query-template-structure.py</a>, that attempts to automate this game of twenty questions. Below we see the result of running the script on the Rotokas dictionary file <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a>:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/query-template-structure.py samples/Rotokas/ROTRT.DIC
\ps     845     100%
\ge     845     100%
\gp     840     99%
\dt     838     99%
\xp     705     83%
\xe     705     83%
\ex     705     83%
\rt     339     40%
\nt     162     19%
\cmt    119     14%
\eng    87      10%
\sf     51      6%
\rdp    36      4%
\arg    31      3%
\cd     28      3%
\sa     20      2%
\cm     19      2%
\ig     10      1%
\dx     9       1%
\vx     8       0%
\alt    8       0%
\cl     7       0%
\am     7       0%
\wf     2       0%
\sc     1       0%
</pre></td></tr>
</table>

<p>The output tells us that the fields <tt>\ps</tt> and <tt>\ge</tt> are found in all of the entries. The remaining fields do not appear in all of the entries, but two of them (<tt>\gp</tt> and <tt>\dt</tt>) appear in virtually all. The remaining fields appear with varying degrees of frequency.</p>

<p>The script works as follows: First, the path to a Shoebox dictionary file is obtained from the command-line. Second, the file is parsed into a dictionary object and a list of entries are retrieved with the function <tt>get_entries()</tt>, which, given a filepath to a Shoebox dictionary, will return a list of entries.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def get_entries(filepath) :
    fp = StandardFormatFileParser(filepath)
    sff = fp.parse()
    return sff.getEntries()
</pre></td></tr>
</table>

<p>The function <tt>process_entries()</tt> then keeps track of the distribution of fields across entries using a dictionary data structure.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def process_entries(entries) :
    counter = {}
    i = 0
    for e in entries :
        for fm in e.getFieldMarkers() :
            try :
                counter[fm] = counter[fm] + 1 
            except :
                counter[fm] = 1
    return counter
</pre></td></tr>
</table>

<p>The results are then printed out by the function <tt>print_results()</tt>, which sorts the dictionary by value in ascending order and then reserves that order. The result is that the most common field markers come first and the least common field markers come last. The field markers are then printed out along with the number of entries in which they appear and what percentage of all entries that represents.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>
def print_results(entries, counter) :
    totalEntries = len(entries)
    fieldMarkers = sort_by_value(counter)
    fieldMarkers.reverse()
    for fieldMarker in fieldMarkers :
        numEntries = counter[fieldMarker]
        pctEntries = ((100.0 * numEntries)/totalEntries)
        print "\%s\t%i\t%i%%" % (fieldMarker, numEntries, pctEntries)
</pre></td></tr>
</table>

<p>More sophisticated analysis of entry templates is of course possible. For example, this script does not reveal whether a given field has more than one value---i.e., it does not distinguish between unique and non-unique fields. We leave this as an exercise for the reader.</p>



<a name="casestudy7"></a>
<h3>Case 7: Validating Field Data Against Range Sets</h3>
<p>One particularly useful feature of Shoebox is the ability to restrict the possible values of a field. For example, part of speech information usually refers to a restricted set of categories (e.g., Noun, Verb, Adjective, Adverb, etc.). In the part-of-speech field of a Shoebox lexicon, one may therefore wish to restrict the possible values to a restricted inventory (e.g., <tt>N</tt>, <tt>V</tt>, <tt>ADJ</tt>, and <tt>ADV</tt>), which in Shoebox is called a <b>range set</b>.</p>

<p>To see the range set for a particular field, you must select the pull-down menu <b>Database</b> and select <b>Properties</b>, as shown in the following screenshot.</p>

<p><img src="images/screenshot-rangeset-1.jpg"></p>

<p>You can then select a specific field from list of those recognized by the database, as shown in the following screenshot.</p>

<p><img src="images/screenshot-rangeset-2.jpg"></p>

<p>From this list, we will select a particular field and examine its range set. In the following screenshot, the part-of-speech field has been selected.</p>

<p><img src="images/screenshot-rangeset-3.jpg"></p>

<p>If we select the range set for the part-of-speech field, we can see whether the field has a range set defined for it---in this case, it does---and which elements are in it.</p>

<p><img src="images/screenshot-rangeset-4.jpg"></p>

<p>Unfortunately, when you add or edit a range set within Shoebox, any old entries that are in conflict with the new range set will not be automatically flagged. In fact, the only time that Shoebox enforces the range set for a data field is when you attempt to save changes to that field. In other words, only when an entry is created or edited will the range set be enforced.</p> 

<p>What is interesting about this particular problem is that its solution involves two files: the actual Shoebox dictionary file and a metadata file used by Shoebox which defines the range set. Below we contrast two metadata definitions of the part-of-speech (<tt>\ps</tt>) field: one with and one without a range set.</p>

<table border="1">
<tr>
  <td><b>No Range Set</b></td>
  <td><b>Range Set</b></td>
</tr>
<tr>
  <td bgcolor="#CCFFFF" valign="top"><pre>
\+mkr ps
\nam Part of Speech
\lng Default
\mkrOverThis fri
\-mkr</pre></td>
  <td bgcolor="#CCFFFF" valign="top"><pre>
\+mkr ps
\nam Part of Speech
\lng Default
\rngset N V 
\mkrOverThis fri
\-mkr</pre></td>
</tr>
</table>

<p>Using the NLTK, we can validate the Shoebox file against the metadata and ensure that all of the field values conform to the defined range sets for their field markers (see <a href="#parsingandvalidation">Parsing and Validation</a> for an explanation of the validation errors).</p>

<p>The script <a href="../bin/validate-shoebox.py">validate-shoebox.py</a> takes a Shoebox dictionary file and a dictionary type file and validates the dictionary file against the metadata of the dictionary type file. It is run as follows:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python tutorial/scripts/validate-shoebox.py --s=samples/Frisian1/FriRt.dic --m=samples/Frisian1/FrisianD.typ
</pre></td></tr>
</table>

<p>In this case, running the script should do nothing. When a dictionary conforms to its metadata, the script produces no output. It is only when there are discrepancies between data and metadata that output is produced. To see how this works, we will run the same script on a modified version of the metadata, <a href="../samples/Frisian1/FrisianDAlt.typ">FrisianDAlt.typ</a>, where the field marker <tt>ps</tt> has the range set of <tt>N</tt> and <tt>V</tt>. When the script is run on this alternative metadata, the results are quite different.</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python tutorial/scripts/validate-shoebox.py --s=samples/Frisian1/FriRt.dic --m=tutorial/FrisianDAlt.typ
[\_sh v3.0  400  Frisian Dictionary]
Traceback (most recent call last):
  File "tutorial/scripts/validate-shoebox.py", line 37, in ?
    ev.validate()
  File "/home/stuart/workspace/Shoebox/shoebox/shoebox/shoebox.py", line 395, in validate
    raise BadFieldValue(BadFieldValue.FIELD_VALUE_ERROR_RANGE_SET, e, f, fmm)
shoebox.shoebox.BadFieldValue: 'Range Set' error in '\ps' field of record 4!
Record:
\fri -ber
\ps V>Adj
\g able
</pre></td></tr>
</table>

<p>To understand what is going on here, we need to look at how the script works.</p>

<p><ol>
  <li>the filenames for the Shoebox dictionary and the metadata file are taken from the command-line</li>
  <li>a MetadataParser is used to construct a Metadata object from the metadata file</li>
  <li>a StandardFormatParser is used to construct a StandardFormatFile object from the dictionary file</li>
  <li>a MetaDataValidator object uses the MetadataFile object and the StandardFormat object to validate the dictionary data</li>
</ol></p>

<p>If the dictionary data conforms to the range set in the metadata, nothing happens. That is, the <tt>validate()</tt> method simply returns true. However, if the dictionary data does not conform to the range set in the metadata, a BadFieldValue error is thrown.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>import sys
from optparse               import OptionParser
from shoebox.shoebox        import MetadataParser, ShoeboxValidator
from shoebox.standardformat import StandardFormatFileParser

# Deal with metadata
fo = open(options.metadata, 'rU')
mdFc = fo.read()
fo.close()
mp = MetadataParser(mdFc)
md = mp.parse()

# Deal with Shoebox
fo = open(options.shoebox, 'rU')
sbFc = fo.read()
fo.close()
fp = StandardFormatFileParser(sbFc)
fp.setHeadFieldMarker(md.getHeadFieldMarker())
sb = fp.parse()

# Validate
ev = ShoeboxValidator()
ev.setMetadata(md)
ev.setShoebox(sb)
ev.validate()
</pre></td></tr>
</table>

<p>If there are any inconsistencies, the method <tt>validate()</tt> will raise a BadFieldValue exception.</p>



<a name="casestudy8"></a>
<h3>Case 8: Finding Entries that Conform to a Particular Profile</h3>

<p>One common task in the analysis of dictionaries is the extraction of entries conforming to a particular profile. For example, it is sometimes useful to find words that are of a particular length or words that begin with a particular prefix or end with a particular suffix. By way of illustration, the script <a href="../bin/find-long-vowel-final-entries.py">find-long-vowel-final-entries.py</a> extracts all dictionary entries that end with a long vowel. Here we illustrate its use with <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a>:</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-long-vowel-final-entries.py samples/Rotokas/ROTRT.DIC
kaa [V.A] 'gag'
kaa [V.B] 'strangle'
kaa [N.M] 'cooking banana'
kaepaa [N.N] 'wheelbarrow/basket'
kakupaa [N.N] 'landslide/mudslide'
...
</pre></td></tr>
</table>

<p>Here's how it works. The dictionary file is first parsed using the StandardFormatFileParser. Then all of the entries obtained are then iterated over in a <tt>for</tt> loop. As the <tt>for</tt> loop goes through each entry, various fields are obtained from it and the entry is printed out if its head field matches the regular expression that defines a word-final long vowel. (The regular expression simply looks for a string-final sequence of two identical vowel letters. For more on regular expressions, see this <a href="http://www.amk.ca/python/howto/regex/">regular expression tutorial</a>.)</p>

<p>The desired profile for entries can be made more strict by adding additional conditions. For example, instead of printing all entries ending with a long vowel, the script can be modified so that it prints all entries that are both nouns and end with a long vowel. This is done by obtaining the part-of-speech field in addition to the head field and checking whether the part-of-speech is a noun. In the case of <a href="../samples/Rotokas/ROTRT.DIC">ROTRT.DIC</a>, the part of speech field uses abbreviations that conform to a particular convention: major lexical categories (e.g., noun, verb) are indicated by a single capital letter (e.g., <tt>N</tt>, <tt>V</tt>) followed by a subclass abbreviation with an intervening dot (e.g., <tt>N.N</tt> for neuter noun or <tt>N.M</tt> for masculine noun).</p>

<table width="100%" border="0" bgcolor="#CC99FF">
<tr><td><pre>
$ python bin/find-long-vowel-final-noun-entries.py samples/Rotokas/ROTRT.DIC
kaa [N.M] 'cooking banana'
kaepaa [N.N] 'wheelbarrow/basket'
kakupaa [N.N] 'landslide/mudslide'
kapopaa [N.N] 'wrench/spanner'
kapupiepaa [N.N] 'pincers'
...
</pre></td></tr>
</table>



<!--
<a name="casestudy7"></a>
<h3>Case 8: Automatic Analysis of Word Length and Photactics</h3>

<p>The analysis of word length and photactics can be facilitated by automatically extracting all of the patterns represented in a Shoebox dictionary. (Obviously, the larger the Shoebox deictionary, the greater the likelihood that meaningful results can be obtained.)</p>

<p>???</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>def main() :
    fn = handle_options()
    fp = StandardFormatFileParser(fn)
    sff = fp.parse()

    d = {}
    for e in sff.getEntries() :
        fri = e.getFieldValuesByFieldMarkerAsString(FIELD_MARKER_FRISIAN)
        fri_cv = cv(fri)
        if not d.has_key(fri_cv) :
            d[fri_cv] = 0
        d[fri_cv] = d[fri_cv] + 1

    wordshapes = d.keys()
    wordshapes.sort()
    for ws in wordshapes :
        count = d[ws]
        print "%s %i" % (ws, count)
</pre></td></tr>
</table>

<p>The main trick is transforming a lexical entry in its raw form (a practical orthography where vowel length is indicated by repeating a vowel character---i.e., the long version of <tt>a</tt> is <tt>aa</tt>). The function <tt>cv</tt> does most of the work. It performs a series of transformations on the data, producing a CV template where vowel length is similarly indicated---e.g., producing <tt>CVVCV</tt> from <i>tuuta</i>.</p>

<table width="100%" border="0" bgcolor="#CCFFFF">
<tr><td><pre>def cv(s):
    s = s.lower()
    s = re.sub(r'[^a-z]',     r'-', s)
    s = re.sub(r'[^aeiou\-]', r'C', s)
    s = re.sub(r'[aeiou]',    r'V', s)
    return (s)
</pre></td></tr>
</table>

<p>???</p>
-->



<a name="section4"></a>
<h2>Conclusion</h2>

<p>In this tutorial we have seen how the NLTK can make it easier to manipulate dictionary files produced by Shoebox. In another tutorial, we will see how some of the same tools can be used to work with interlinear texts produced by the same program.</p>



<a name="links"></a>
<h2>Links</h2>

<table>
  <tr>
    <td valign="top"><b>Python</b></td>
    <td>&nbsp;</td>
    <td><a href="http://nltk.sourceforge.net">Natural Language Toolkit (NLTK) Homepage</a><br>
        <a href="http://nltk.sourceforge.net/tutorial/index.html">NLTK Tutorials</a><br>
    </td>
  </tr>
  <tr>
    <td valign="top"><b>Shoebox</b></td>
    <td>&nbsp;</td>
    <td><a href="http://www.python.org">Python Homepage</a><br>
    <a href="http://www.sil.org/computing/shoebox">Shoebox Homepage</a><br>
    <a href="http://www.sil.org/computing/toolbox">Toolbox Homepage</a><br>
    <a href="http://www.sil.org/computing/shoebox/TipList.html">User Tips for Shoebox</a><br>
  </tr>
</table>  

<p><hr></p>

<p><small>The author may be contacted at <a href="stuart-at-zapata-dot-org">stuart-at-zapata-dot-org</a>. Many thanks to those who read drafts of this tutorial and provided feedback: Steven Bird, Brian McWhinney, and Loretta O'Connor. All errors are of course my own.</small></p>

</body>

</html>

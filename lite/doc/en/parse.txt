.. -*- mode: rst -*-
.. include:: ../definitions.txt

====================
Grammars and Parsing
====================

:Authors: Steven Bird, Ewan Klein, Edward Loper
:Version: |version|
:Revision: $Revision$
:Date: $Date$
:Copyright: |copy| |copyrightinfo|
:License: |license|

.. note:: This is a draft.  Please send any feedback to the authors.

------------
Introduction
------------

Early experiences with grammar are often confusing.  Written work
may be graded by a teacher who red-lines all the grammar errors they
won't put up with.  Like the dangling preposition in the last
sentence, or sentences like this one which lack a main verb.  Learning
English as a second language, it may be difficult to discover
which of these errors needs to be fixed.  Correct punctuation is
something of an obsession for many writers and editors (as our own
students have observed).  Of course, it is all in the name of
effective communication.  In the following example, the interpretation
of a relative clause as restrictive or non-restrictive, depends on the
presence of commas alone:

1. a) My dog, Bonus, has black and white spots.  (I have one dog.)
   b) My dog Bonus has black and white spots.  (I have more than one dog.)

It is clear that some of these rules are important.  Others seem
to be vestiges of antiquated style that preoccupies only the most crusty
curmudgeons.  As an example, consider the injunction that :lx:`however` -- when
used to mean *nevertheless* -- must not appear at the start of a sentence.
Pullum argues that Strunk and White were merely insisting that English usage should
conform to "an utterly unimportant minor statistical detail of style
concerning adverb placement in the literature they knew" [languagelog.org].

When reading, we sometimes find that we have to stop and re-read a
sentence in order to resolve an ambiguity.  Curiously, it seems possible
to combine unambiguous words to create an ambiguous sentences:

2. a) Fighting animals could be dangerous.
   b) Visiting relatives can be tiresome.

Perhaps another kind of variation, word order, is easier to understand.
We know that the two sentences *Kim likes Sandy* and *Sandy likes Kim*
have different meanings, and that *likes Sandy Kim* is simply ungrammatical.
Similarly, we know that the following two sentences are equivalent:

3. a) The farmer *loaded* the cart with sand
   b) The farmer *loaded* sand into the cart

However, consider the semantically similar verbs *filled* and *dumped*.
Now the word order cannot be altered (ungrammatical sentences are starred.)

4. a) The farmer *filled* the cart with sand
   b) \*The farmer *filled* sand into the cart
   c) \*The farmer *dumped* the cart with sand
   d) The farmer *dumped* sand into the cart

A further curious fact is that we are able to access the meaning of
sentences we have not encountered.  It is not difficult to concoct an
entirely novel sentence, one that has probably never been used before
in the history of the language, and yet all speakers of the language
will agree about its meaning.  In fact, the set of possible sentences would
seem to be infinite, given that there is no upper bound on length.
Consider the following passage from a children's story, containing a
rather impressive sentence:

   You can imagine Piglet's joy when at last the ship came in sight of
   him. In after-years he liked to think that he had been in Very
   Great Danger during the Terrible Flood, but the only danger he had
   really been in was the last half-hour of his imprisonment, when
   Owl, who had just flown up, sat on a branch of his tree to comfort
   him, and told him a very long story about an aunt who had once laid
   a seagull's egg by mistake, and the story went on and on, rather
   like this sentence, until Piglet who was listening out of his
   window without much hope, went to sleep quietly and naturally,
   slipping slowly out of the window towards the water until he was
   only hanging on by his toes, at which moment, luckily, a sudden
   loud squawk from Owl, which was really part of the story, being
   what his aunt said, woke the Piglet up and just gave him time to
   jerk himself back into safety and say, "How interesting, and did
   she?"  when -- well, you can imagine his joy when at last he saw
   the good ship, Brain of Pooh (Captain, C. Robin; 1st Mate, P. Bear)
   coming over the sea to rescue him...  (from A.A. Milne *In which
   Piglet is Entirely Surrounded by Water*)

Our ability to produce and understand entirely new sentences, of
arbitrary length, demonstrates that the set of well-formed sentences
in English (and any other language) is infinite.

This chapter presents grammars and parsing, as the formal and
computational methods for investigating and modelling the linguistic
phenomena we have been touching on (or tripping over).
As we shall see, patterns of well-formedness and ill-formedness in a
sequence of words can be understood with respect to the internal
:dt:`phrase structure` of the sentences.  We can develop formal
models of these structures using grammars and parsers.

As before, the motivation is natural language *understanding*.  How
much more of the meaning of a text can we access when we can reliably
recognize the linguistic structures it contains?  Having read in a
text, can a program 'understand' it enough to be able to answer simple
questions about "what happened?" or "who did what to whom?"  Also as
before, we will develop simple programs to process annotated corpora
and perform useful tasks.

-------------------
Syntactic Ambiguity
-------------------

We have seen that sentences can be ambiguous.  If we overheard someone
say :lx:`I went to the bank`, we wouldn't know whether it was
a river bank or a financial institution.  This ambiguity concerns
the meaning of the word :lx:`bank`, and is a kind of :dt:`lexical ambiguity`.
There is another kind of ambiguity which cannot be explained in this way.
Consider a sentence like: :lx:`I saw the man with a telescope`.  Who
has the telescope?  To clarify what is going on here, consider the
following pair of sentences:

5. a) The policeman saw a burglar *with a gun*.       (not some other burglar)
   b) The policeman saw a burglar *with binoculars*.  (not with his naked eye)

In both cases, there is a prepositional phrase introduced by
:lx:`with`.  In the first case this phrase modifies the noun
:lx:`burglar`, and in the second case it modifies the verb :lx:`saw`.
In general, how can we determine whether a prepositional phrase
modifies the preceding noun or verb?
The :dt:`Prepositional Phrase Attachment Corpus`, included with NLTK-Lite,
facilitates systematic study of this question.
It contains lines of the following form::

  47830 allow visits between families N
  47830 allow visits on peninsula V
  42457 acquired interest in firm N
  42457 acquired interest in 1986 V

Each line consists of a sentence identifier, a verb, a noun, a
preposition, another noun (the head noun from the prepositional
phrase), and finally an "attachment" (``N`` or ``V``) to indicate
whether the prepositional phrase attaches to (modifies) the noun phrase or the
verb phrase.  The above examples correspond to the following phrase
groupings.

  | allow (NP visits (PP between families))
  | allow (NP visits) (PP on peninsula)
  | acquired (NP interest (PP in firm))
  | acquired (NP interest) (PP in 1986)

Observe in each case that the argument of the verb is either a single
complex expression ``(visits (between families))`` or a pair of
simpler expressions ``(visits) (on peninsula)``.
We can access this corpus from NLTK-Lite as follows:

  >>> from nltk_lite.corpora import ppattach, extract
  >>> from pprint import pprint
  >>> item = extract(2, ppattach.dictionary('training'))
  >>> pprint(item)
  {'attachment': 'N',
   'noun1': 'director',
   'noun2': 'conglomerate',
   'prep': 'of',
   'sent': '2',
   'verb': 'named'}

From the above examples, it would appear that the attachment of the
prepositional phrase is determined by the noun it contains.  However,
we can use this corpus to find examples where other factors come in to play.
The following program uses ``MinimalSet`` to find pairs of entries in the
corpus which have different attachments based on the *verb* only.

  >>> from nltk_lite.utilities import MinimalSet
  >>> ms = MinimalSet()
  >>> for entry in ppattach.dictionary('training'):
  ...     target  = entry['attachment']
  ...     context = (entry['noun1'], entry['prep'], entry['noun2'])
  ...     display = (target, entry['verb'])
  ...     ms.add(context, target, display)
  >>> for context in ms.contexts():
  ...     print context, ms.display_all(context)

Here is one of the pairs found by the program.

  | received (NP offer) (PP from group)
  | rejected (NP offer (PP from group))

This finding gives us clues to a structural difference: the verb
:lx:`receive` usually comes with two following arguments; we receive
something *from* someone.  In contrast, the verb :lx:`reject` only
needs a single following argument; we can reject something without
needing to say where it originated from.


--------------------------------
Representing Syntactic Structure
--------------------------------

We have been discussing structural differences between sentences, and we have
been probing these structures by substituting words and phrases.  In this section
we show how sentence structures can be represented using :dt:`syntactic trees`.

Recursion
---------

Observe that sentences can be nested within sentences, with no limit to the depth.

 | Jodie won the 100m freestyle

 | The Age reported that
 |   Jodie won the 100m freestyle

 | Sandy said
 |   The Age reported that
 |     Jodie won the 100m freestyle

 | I think
 |   Sandy said
 |     The Age reported that
 |       Jodie won the 100m freestyle

It is quite clear that language exhibits :dt:`recursion`.
More subtly, note that a sentence can be a :dt:`constituent` of
a larger sentence.  Next we explore this notion of constituency in more detail.

Constituency
------------

A well-formed sentence of a language is more than an arbitrary
sequence of words from the language.  Certain kinds of words usually
go together.  For instance, determiners like ``the`` are typically
followed by adjectives or nouns, but not by verbs.  Groups of words
form intermediate structures called phrases or :dt:`constituents`.
These constituents can be identified using standard syntactic tests,
such as substitution, movement and coordination.  For example, if a
sequence of words can be replaced with a pronoun, then that sequence
is likely to be a constituent.  According to this test, we can infer
that the italicised string in the following example is a constituent:


1. *Ordinary daily multivitamin and mineral supplements* could 
   help adults with diabetes fight off some minor infections.
#. *They* could help adults with diabetes fight off some minor infections.

The structure of a sentence may be represented using a phrase
structure tree, in which the terminal symbols are the words of the
sentence, the pre-terminal symbols are parts of speech, and the
remaining non-terminals are syntactic constituents.  An example of
such a tree is shown below. For those trained in
theoretical linguistics, the lexical categories (i.e., the nonterminal
symbols immediately dominating the words of the tree) may appear
strange.  This is because we have used used labels drawn from the
Brown Corpus part-of-speech tag set (please see the chapter on tagging
for discussion).

.. figure:: ../images.parsing/parse_tree.png

   _`Example Tree 1`

Phrase Structure Trees
----------------------

Phrase structure is typically represented using a tree.  Consider the
following example:

.. figure:: ../images.parsing/trees_tree.png
   :scale: 50

The tree is a set of connected nodes, each of which is labeled with a category.
Linguistic trees grow upside down: the
node labeled ``S`` is the *root* of the tree, while the *leaves* of the
tree are labeled with the words 'Lee', 'saw', 'the' and 'dog'. It also
common to use
a family metaphor to talk about the relationships of nodes in a tree: for example, ``S`` is the
*parent* of ``VP``; conversely ``VP`` is a *daughter*  (or *child*) of
``S``.  Also, since ``NP`` and ``VP`` are both daughters of ``S``,
they are also *sisters*. 

Although it is helpful to represent trees in a graphical format, for
computational purposes we usually need a more text-oriented
representation. One standard method is to use a combination of bracket
and labels to indicate the structure, as shown here::

   (S 
       (NP  'Lee')
       (VP 
             (V 'saw')
             (NP 
                   (Det 'the')
                   (N  'dog'))))

Trees in NLTK-Lite
------------------

The ``nltk_lite.tree`` module defines classes and functions for
working with trees.

.. Note:: The ``nltk_lite.tree`` module currently has no direct
   support for representing movement, traces, and co-indexing.  We plan
   to extend the class to support these features more fully in the
   future.

1.  The node value is a string containing
    the tree's constituent type (e.g., ``NP`` or ``VP``).
#.  The children encode the hierarchical contents of the tree.

.. Note:: Although the ``Tree`` class is usually used for encoding
   syntax trees, it can be used to encode *any* homogeneous hierarchical
   structure that spans a text (such as morphological structure or
   discourse structure).  In the general case, leaves and node values do
   not have to be strings.

A ``Tree`` with node value
`n` and children
`c`:subscript:`1`,
`c`:subscript:`2`, ...
`c`:subscript:`n` is
written ``(n``:
`c`:subscript:`1`
`c`:subscript:`2` ...
`c`:subscript:`n`\ ``)``.

``Tree``\ s are created with the ``Tree constructor``, which takes a
node value and zero or more children.
Here we see a simple tree with a single child node, itself a token::

  >>> from nltk_lite.parse.tree import Tree
  >>> tree1 = Tree('NP', ['John'])
  >>> tree1
  (NP: 'John')

Here is an example with two children::

  >>> tree2 = Tree('NP', ['the', 'man'])
  >>> tree2
  (NP: 'the' 'man')

Finally, here is a more complex example, where one of the
children is itself a tree::

  >>> tree3 = Tree('VP', ['saw', tree2])
  >>> tree3
  (VP: 'saw' (NP: 'the' 'man'))

A tree's node value is accessed with the ``node`` property:: 

  >>> tree1.node
  'NP'

A tree's children are accessed by indexing:: 

  >>> tree3[0]
  'saw'
  >>> tree3[1]
  (NP: 'the' 'man')
  >>> for child in tree3:
  ...     print child
  saw
  (NP: 'the' 'man')

The printed representation for complex trees can be difficult to read.
In these cases, the ``draw`` method can be very useful.  This method
opens a new window, containing a graphical representation of the tree::

  tree3.draw()

The tree display window allows you to zoom in and out;
to collapse and expand subtrees; and to print the graphical
representation to a postscript file. 

To compare multiple trees in a single window, use the ``draw_trees()``
method, from the ``nltk_lite.draw.tree`` module::

  from nltk_lite.draw.tree import draw_trees
  draw_trees(tree1, tree2, tree3)

The ``Tree`` class implements a number of other useful methods.  See
the ``Tree`` reference documentation for more information about these
methods.

  >>> tree3.leaves()
  ['saw', 'the', 'man']
  >>> tree3.height()
  3

..  Mention tree positions? -->

Initializing Trees from Strings 
-------------------------------

A convenient way to initialize a large tree is from a labelled
bracketing::

  >>> from nltk_lite.parse import bracket_parse
  >>> sent = '(VP (VBD saw) (NP (DT the) (NN man)))'
  >>> tree = bracket_parse(sent)
  >>> tree
  (VP: (VBD: 'saw') (NP: (DT: 'the') (NN: 'man')))

Reading Trees from the Treebank Corpus
--------------------------------------

The ``nltk_lite.corpora`` module defines the ``treebank`` corpus,
which contains a collection of hand-annotated parse trees for English
text.

..  Add a reference to LDC here?

  >>> from nltk_lite.corpora import treebank, extract
  >>> print extract(0, treebank.parsed())
  (S:
    (NP-SBJ:
      (NP: (NNP: 'Pierre') (NNP: 'Vinken'))
      (,: ',')
      (ADJP: (NP: (CD: '61') (NNS: 'years')) (JJ: 'old'))
      (,: ','))
    (VP:
      (MD: 'will')
      (VP:
        (VB: 'join')
        (NP: (DT: 'the') (NN: 'board'))
        (PP-CLR:
          (IN: 'as')
          (NP: (DT: 'a') (JJ: 'nonexecutive') (NN: 'director')))
        (NP-TMP: (NNP: 'Nov.') (CD: '29'))))
    (.: '.'))



--------------------
Context Free Grammar
--------------------

In the context of formal and computational modelling, a language is
often viewed as a set of well-formed sentences.  Sequences of words
which are not grammatical are excluded from this set.  Now, since
there is no upper-bound on the length of a sentence, the number of
possible sentences is unbounded.  Given that the resources of a
computer, however large, are still finite, it is necessary to devise a
finite description of this infinite set.  Such descriptions are called
:dt:`grammars`.

A grammar of a language is a means of specifying which strings belong
to the language, and as we have just remarked, it needs to be a finite
specification (rather than, say, just a list of all the grammatical
sentences). We have already encountered this idea of a finite
specification in the context of regular expressions.  For example, the
expression ``a+`` describes the infinite set ``{a, aa, aaa, aaaa,
...}``.  Apart from their compactness, grammars usually capture
important structural and distributional properties of the language
being studied, and can be used to systematically map between sequences
of words and abstract representations of their meaning.  Thus, even if
we were to impose an upper bound on sentence length to ensure the
language was finite, we would still want to come up with a compact
representation in the form of a grammar.

A grammar is a formal system which specifies which sequences of words
are well-formed in the language, and which provides one or more phrase
structures for the sequence.  We will focus our attention on a
particular kind of grammar called a :dt:`context-free grammar`
(CFG), which is a collection of rules or *productions* of the form
``S`` |rarr| ``NP VP``.  We interpret this production as saying that a
constituent of category ``S`` can consist of subconstituents of
categories ``NP`` and ``VP``. Similarly, the production ``VB`` |rarr|
``'help'`` means that the constituent of category ``VB`` can consist
of the string ``help``.  For a phrase structure tree to be well-formed
relative to a grammar, each non-terminal node and its children must
correspond to such a production in the grammar.


A Simple Grammar
----------------

Let's start off by looking at a simple context-free grammar, `G1`_:

_`G1`

 | S |rarr| NP VP
 | NP |rarr| Det N
 | NP |rarr| Det N PP
 | VP |rarr| V NP PP
 | VP |rarr| V NP
 | VP |rarr| V
 | PP |rarr| P NP
 |
 | Det |rarr| 'the'
 | Det |rarr| 'a'
 | N |rarr| 'man' | 'park' | 'dog' | 'telescope'
 | V |rarr| 'saw' | 'walked'
 | P |rarr| 'in' | 'with'

This grammar contains productions involving various syntactic categories,
as laid out in the following table:

======    ====================    =====================
Syntactic Categories
-------------------------------------------------------
Symbol    Meaning                 Example
======    ====================    =====================
S         sentence                *the man walked*
NP        noun phrase 		  *a dog*
VP        verb phrase 		  *saw a park*
PP        prepositional phrase 	  *with a telescope*
..	  ..                      ..
Det       determiner              ..
N         noun                    ..
V         verb                    ..
P         preposition             ..
======    ====================    =====================

In the following discussion we will make heavy use of these terms:

==============================  ==============================================================
Grammar Terminology
----------------------------------------------------------------------------------------------
Term                            Definition and Examples
==============================  ==============================================================
non-terminal, category          any of the above symbols except the words, e.g. `S`, `NP`, `P`
terminal                        any of the above words, e.g. 'walked'
grammatical production          any production without a terminal on the right-hand side
lexical production              any production with a terminal on the right-hand side
pre-terminal, lexical category  the non-terminal on the left-hand side of a lexical production
==============================  ==============================================================

If we were to parse the string `The dog saw a man in the park` using
`G1`_, we would end up with two distinct analyses, as shown 
below:

===================  ==================
Structural Ambiguity
---------------------------------------
VP modification      NP modification
===================  ==================
|parse_tree2|        |parse_tree3|
===================  ==================

.. |parse_tree2| image:: ../images.parsing/parse_tree2.png
                 :scale: 40

.. |parse_tree3| image:: ../images.parsing/parse_tree3.png
                 :scale: 40


Our grammar admits two distinct structures for this sentence, i.e.
the sentence is :dt:`structurally ambiguous`.  The ambiguity in
question is often called a :dt:`PP attachment ambiguity`, as we saw earlier
in this chapter.  It is an ambiguity about attachment since the
``PP`` (prepositional phrase) `in the park` needs to be attached
to one of two places in the tree: either
as a daughter of ``VP`` or else as a daughter of ``NP``.

There is also a subtle difference in interpretation: where the ``PP``
is attached to ``VP``, the intended interpretation is that the event
of seeing took place in the park, while if the ``PP`` is attached to
``NP``, being in the park is a property of the ``NP`` referent; that
is, the man was in the park, but the agent of the seeing |mdash| the
dog |mdash| might have been somewhere else (e.g., sitting on the
balcony of an apartment overlooking the park).  As we will see,
dealing with ambiguity is a key challenge in parsing.

Notice that the language accepted by this grammar is finite.

Recursion
---------

As we have seen, there is no upper bound on the length of
sentences of a natural language. The
main mechanism we use to capture this unboundedness is :dt:`recursion`. A
grammar is said to be :dt:`recursive` if a category occurring on the
lefthand side of a production also appears on the righthand side of a
production. If this dual occurrence takes place in *one and the same
production*, then we have :dt:`direct recursion`; otherwise we have
:dt:`indirect recursion`. These two cases are both illustrated in the
following grammar:

_`G2`
 | S  |rarr| NP VP
 | NP |rarr| Det N
 | NP |rarr| Det N PP
 | VP |rarr| VP Conj VP
 | VP |rarr| V NP PP
 | VP |rarr| V NP
 | VP |rarr| V S
 | VP |rarr| V
 | PP |rarr| P NP
 |
 | Det |rarr| 'the'
 | Det |rarr| 'a'
 | N |rarr| 'man' | 'woman' | 'park' | 'dog' | 'telescope'
 | V |rarr| 'saw' | 'barked' | 'disappeared' | 'said' | 'gave'
 | P |rarr| 'in' | 'with' | 'to'
 | Conj |rarr| 'and' | 'or'

That is, the production ``VP`` |rarr| ``VP Conj VP`` involves direct
recursion on the category ``VP``\, whereas indirect recursion on ``S``
arises from the combination of two productions, namely ``S`` |rarr|
``NP VP`` and ``VP`` |rarr| ``V S``.  To illustrate, here is a
phrase structure tree involving coordinated verb phrases:

.. figure:: ../images.parsing/recursive_parse1.png

   _`Figure 2:` Coordinated VP Phrase Structure Tree

Heads, Complements and Modifiers
--------------------------------

The grammar `G2`_ correctly generates examples like these,
corresponding to the four productions with ``VP`` on the lefthand side:

#. The woman gave the telescope to the dog.
#. The woman saw a man.
#. A man said that the woman disappeared.
#. The dog barked.

That is, `gave` can occur with a following ``NP`` and ``PP``; 
`saw` can occur with a following ``NP``; 
`said` can occur with a following ``S``; 
and `barked` can occur with no following phrase.
In these cases, ``NP``, ``PP`` and ``S`` are called :dt:`complements`
of the respective verbs, and the verbs themselves are called
:dt:`heads` of the verb phrase.

However, there are fairly strong constraints on what verbs can occur
with what complements. Thus, we would like our grammars to mark the
following examples as ungrammatical:
 
#. \*The woman disappeared the telescope to the dog.
#. \*The dog barked a man.
#. \*A man gave that the woman disappeared.
#. \*A man said.

.. caution:: It should be borne in mind that it is possible to create
   examples which involve "non-standard" but interpretable
   combinations of verbs and complements. Thus, we can, at a stretch,
   interpret *the man disappeared the dog* as meaning that the man
   made the dog disappear. We will ignore such examples here.

How can we ensure that our grammar correctly excludes the
ungrammatical examples above?  We need some way of constraining
grammar productions which expand ``VP`` so that verbs *only* cooccur
with their correct complements. We do this by dividing the class of
verbs into \'subcategories\', each of which is associated with a
different set of complements. For example, :dt:`transitive
verbs` such as `saw`, `kissed` and `hit` require a following ``NP``
object complement. Let's introduce a new label for such verbs, namely
``V_tr``, and use it in the following productions:

| VP |rarr| V_tr NP
| V_tr |rarr| 'saw' | 'kissed' | 'hit'

Now `*the dog barked the man` is excluded since we haven't listed
`barked` as a ``V_tr``, but `the woman saw a man` is still allowed.
The following table provides more examples of labels for verb subcategories.

======    ====================    ========================
Verb Subcategories
----------------------------------------------------------
Symbol    Meaning                 Example
======    ====================    ========================
V_itr     intransitive verb       *barked*
V_tr      transitive verb         *saw a man*
V_dat     dative verb             *gave a dog to a man*
V_sent    sentential verb         *said that a dog barked*
======    ====================    ========================

The revised grammar for ``VP`` will now look like this:

| VP |rarr| V_dat NP PP
| VP |rarr| V_tr NP
| VP |rarr| V_sent S
| VP |rarr| V_itr 
|
| V_dat |rarr| 'gave' | 'donated' | 'presented'
| V_tr |rarr| 'saw' | 'kissed' | 'hit' | 'sang'
| V_sent |rarr| 'said' | 'knew' | 'alleged'
| V_itr |rarr| 'barked' | 'disappeared' | 'elapsed' | 'sang'

Notice that with this approach, a given lexical item can belong to more
than one subcategory. For example, `sang` can occur both with and
without a following ``NP`` complement.


Lexical Acquisition
-------------------

We have seen increasingly detailed grammars, e.g. identifying different kinds
of verbs.  How are we to acquire this information in a scalable way?  One method
is to return to the chunking methods.  For example, we saw in the chunk chapter that
it is possible to collapse chunks down to the chunk label, thus::

  gave NP
  gave up NP in NP
  gave NP up
  gave NP help
  gave NP to NP

We can use this as raw material to guide us as we manually construct more grammar productions.

Context Free Grammars in NLTK-Lite
----------------------------------

Context free grammars are encoded by the ``Grammar`` class.  The easiest
way to construct a grammar object is from the standard string representation
of grammars::

  >>> from nltk_lite.parse import cfg
  >>> grammar2 = cfg.parse_grammar('''
  ...   S -> NP VP
  ...   VP -> V NP | V NP PP
  ...   V -> "saw" | "ate"
  ...   NP -> "John" | "Mary" | "Bob" | Det N | Det N PP
  ...   Det -> "a" | "an" | "the" | "my"
  ...   N -> "dog" | "cat" | "cookie"
  ...   PP -> P NP
  ...   P -> "on" | "by" | "with"
  ...   ''')

  >>> from nltk_lite import tokenize, parse
  >>> sent = list(tokenize.whitespace("Mary saw Bob"))
  >>> rd_parser = parse.RecursiveDescent(grammar2)
  >>> for p in rd_parser.get_parse_list(sent):
  ...      print p
  (S: (NP: 'Mary') (VP: (V: 'saw') (NP: 'Bob')))
  

Exercises
---------

1. a) Encode `Example Tree 1`_ as a labeled bracketing and use the
      ``nltk_lite.parse`` module's ``bracket_parse()`` method to
      check that it is well-formed. Now use the ``draw()``
      method from the ``Tree`` class in module
      ``nltk_lite.parse.tree`` to display the tree.

   b) Extend `G2`_ with productions which expand prepositions as
      intransitive, transitive and requiring a ``PP``
      complement. Based on these productions, use the method of the
      preceding exercise to draw
      a tree for the sentence `Lee ran away home`\.

   c) As in (a) above, draw a tree for `The woman saw a man last Thursday`.

2. Pick some common verbs.

  a) Write a program to find those verbs in the PP Attachment Corpus
     included with NLTK-Lite.  Find any cases where the same verb
     exhibits two different attachments, but where the first noun,
     or second noun, or preposition, stay unchanged (as we saw in
     the PP Attachment Corpus example data above).

  b) Devise CFG grammar productions to cover some of these cases.

3. **Lexical Acquisition:**
   Identify some English verbs that are near-synonyms, such as the
   :lx:`dumped/filled/loaded` example from earlier in this chapter.
   Use the chunking method to study the complementation patterns of
   these verbs.  Create a grammar to cover these cases.  Can the verbs
   be freely substituted for each other, or are their constraints?
   Discuss your findings.


-------
Parsing
-------

A :dt:`parser` is a computational system which processes input sentences
according to the productions of a grammar, and builds one or more
constituent structures which conform to the grammar. While a
grammar is a declarative specification of well-formedness,  a
parser is a procedural interpretation of the grammar.  We can think of
the parser as searching through the space of possible trees licensed
by a grammar, to find one that has the required sentence along its fringe.
In this chapter we will present context-free grammars, and describe some
simple parsers that work with them.

Parsing is important in linguistics and natural language processing
for a variety of reasons.  A parser permits a grammar to be evaluated
against a potentially large collection of test sentences, helping the
linguist to identify shortcomings in their analysis.  A parser can
also be used as a model of psycholinguistic processing, with the goal
of explaining the processing difficulties that humans have with
certain syntactic constructions (e.g., the so-called "garden path"
sentences).  There are many NL applications which involve parsing at
some point; for example, we would expect the natural language input to
a question-answering system to undergo parsing as an initial step.

The Parser Interface 
--------------------

The ``parse`` module defines the ``ParseI`` interface, which defines
the set of methods which all parsers should support.  The ``ParseI``
interface defines two methods:

..  
 I say "n best" and "in descending order of quality" here,
 but so far we've only talked about grammars with no notion of
 parse quality.  Will that be confusing?

1. The ``parse`` method returns the single best parse for a given
   text.  The text is represented as a list of word tokens.  If no
   parses are found for the given text, then ``parse`` returns
   ``None``.

#. The ``get_parse_list`` method returns a list of the parses for the
   given text.

For example, here is what the recursive descent parser generates for a
simple sentence and grammar::

  >>> from nltk_lite import tokenize
  >>> sent = list(tokenize.whitespace('I saw a man in the park'))
  >>> from nltk_lite import parse
  >>> rd_parser = parse.RecursiveDescent(grammar)

  >>> for p in rd_parser.get_parse_list(sent):
  ...     print p
  (S:
    (NP: 'I')
    (VP:
      (V: 'saw')
      (NP:
        (Det: 'a')
        (N: 'man')
        (PP: (P: 'in') (NP: (Det: 'the') (N: 'park'))))))
  (S:
    (NP: 'I')
    (VP:
      (V: 'saw')
      (NP: (Det: 'a') (N: 'man'))
      (PP: (P: 'in') (NP: (Det: 'the') (N: 'park')))))


Recursive Descent Parsing 
-------------------------

The simplest kind of parser interprets the grammar as a specification
of how to break a high-level goal into several lower-level subgoals.
The top-level goal is to find an ``S``.  The ``S`` |rarr| ``NP VP``
production permits the parser to replace this goal with two subgoals:
find an ``NP``, then find a ``VP``.  Each of these subgoals can be
replaced in turn by sub-sub-goals, using productions that have ``NP``
and ``VP`` on their left-hand side.  Eventually, this expansion
process leads to subgoals such as: find the word ``telescope``.  Such
subgoals can be directly compared against the input string, and
succeed if the next word is matched.  If there is no match the parser
must back up and try a different alternative.

The recursive descent parser builds a parse tree during the above
process.  With the initial goal (find an ``S``), the ``S`` root node
is created.  As the above process recursively expands its goals using
the productions of the grammar, the parse tree is extended downwards
(hence the name *recursive descent*).  We can see this in action using
the parser demonstration ``nltk_lite.draw.rdparser``.  To run this
demonstration, use the following commands::

  >> from nltk_lite.draw import rdparser
  >> rdparser.demo()

Six stages of the execution of this parser are shown below:

+----------------------------------------------------------------------------------+
|                        Six Stages of a Recursive Descent Parser                  |
+===========================+==========================+===========================+
| 1. Initial stage          | 2. After two productions | 3. After matching "the"   |
|                           |                          |                           |
| |rdparser1|               | |rdparser2|              | |rdparser3|               |
+---------------------------+--------------------------+---------------------------+
| 4. Failing to match "man" | 5. Completed parse       | 6. Backtracking           |
|                           |                          |                           |
| |rdparser4|               | |rdparser5|              | |rdparser6|               |
+---------------------------+--------------------------+---------------------------+

.. |rdparser1| image:: ../images.parsing/rdparser1.png
   :scale: 50
.. |rdparser2| image:: ../images.parsing/rdparser2.png
   :scale: 50
.. |rdparser3| image:: ../images.parsing/rdparser3.png
   :scale: 50
.. |rdparser4| image:: ../images.parsing/rdparser4.png
   :scale: 50
.. |rdparser5| image:: ../images.parsing/rdparser5.png
   :scale: 50
.. |rdparser6| image:: ../images.parsing/rdparser6.png
   :scale: 50


.. Discussion: choosing which of several possible productions to apply;
   backtracking; termination.

Problems with recursive descent parsing: considers structures and
words that are not attested; backtracking may discard parsed
constituents that need to be rebuilt; for example, backtracking over
``VP`` |rarr| ``V NP`` will discard the structures created for the ``V``
and ``NP`` non-terminals.  If the parser then proceeds with ``VP``
|rarr| ``V NP PP``, then the structures for the ``V`` and ``NP`` must be
created again.

Recursive descent parsing is a kind of *top-down parsing*.  These use
the grammar to *predict* what the input will be, before inspecting any
input.  However, since the input is available to the parser all along,
it would be more sensible to consider the input sentence from the very
beginning.  Such an approach is called *bottom-up parsing*, and is the
topic of the next section.

The Recursive Descent Parser in NLTK
------------------------------------

The ``nltk_lite.parse`` module defines ``RecursiveDescent``, a
simple recursive implementation of a top-down parser.  Unlike the
shift-reduce parser, this parser is guaranteed to find all parses for
a sentence.  But because it's a simple recursive top-down parser, it
can enter an infinite loop if the grammar contains a left-recursive
production.

Recursive descent parsers are created from ``Grammars`` by the
``RecursiveDescent`` constructor.

  >>> from nltk_lite.parse import *
  >>> rd_parser = RecursiveDescent(grammar)

The following example shows the trace output generated by
``rd_parser`` on a simple sentence::

  >>> sent = list(tokenize.whitespace('I saw a man'))
  >>> rd_parser.trace()
  >>> rd_parser.get_parse_list(sent)
  [(S: (NP: 'I') (VP: (V: 'saw') (NP: (Det: 'a') (N: 'man'))))]

.. note:: The constructor takes an optional parameter ``trace``.  If
          ``trace`` is greater than zero, then the parser will describe the
          steps that it takes as it parses a text.

Problems with the Recursive Descent Parser
------------------------------------------

(Repeated creation of subtrees; creation of trees that do not have any
relationship to the sentence being parsed; left-recursion problem)

Shift-Reduce Parsing 
--------------------

The simplest kind of bottom-up parsing is known as shift-reduce
parsing.  The parser repeatedly pushes the next input word onto a stack;
this is the *shift* operation.  If the top *n* items on the stack
match the *n* items on the right-hand side of some production, then
they are all popped off the stack, and the item on the left-hand side
of the production is pushed on the stack.  This replacement of the top
*n* items with a single item is the *reduce* operation.  The parser
finishes when all the input is consumed and there is only one item
remaining on the stack, a parse tree with an ``S`` node as its root.


.. 
 To do: add examples and motivate more - what are we doing with
 bottom up - find little pieces and expand...


.. note::
 Note that the reduce operation may only be applied to the top of the stack.
 Reducing items lower in the stack must be done before later items are pushed onto
 the stack.


The shift-reduce parser builds a parse tree during the above process.
If the top of stack holds the word ``dog`` and if the grammar has a
production ``N`` |rarr| ``dog`` then the reduce operation causes the word
to be replaced with the parse tree for this production.  For
convenience we will represent this tree as ``N(dog)``.  At a later
stage, if the top of the stack holds two items ``Det(the) N(dog)`` and
if the grammar has a production ``NP`` |rarr| ``Det N`` then the reduce
operation causes these two items to be replaced with ``NP(Det(the),
N(dog))``.  This process continues until a parse tree for the entire
sentence has been constructed.  We can see this in action using the
parser demonstration ``nltk_lite.draw.srparser``.  To run this
demonstration, use the following commands::

  from nltk_lite.draw import srparser
  srparser.demo()

Six stages of the execution of this parser are shown below:

.. 
   To do: use letter identifiers for subfigures.

.. figure::../images.parsing/empty.png

   Six Stages of a Shift-Reduce Parser: initial, after one shift,
   after shift reduce shift reduce, after recognizing the second NP,
   complex NP, final step. 

.. image:: ../images.parsing/srparser1.png
.. image:: ../images.parsing/srparser2.png
.. image:: ../images.parsing/srparser3.png
.. image:: ../images.parsing/srparser4.png
.. image:: ../images.parsing/srparser5.png
.. image:: ../images.parsing/srparser6.png


A shift-reduce parser may fail to parse the sentence, even though the
sentence is well-formed according to the grammar.  In such cases,
there are no remaining input words to shift, and there is no way to
reduce the remaining items on the stack, as exemplified in the left
example below.  The parser entered this blind alley at an earlier
stage shown in the middle example below, when it reduced instead of
shifted.  This situation is called a *shift-reduce conflict*.  At
another possible stage of processing shown in the right example below,
the parser must choose between two possible reductions, both matching
the top items on the stack: ``V`` |rarr| ``V NP PP`` or ``NP`` |rarr|
``NP PP``.  This situation is called a *reduce-reduce conflict*.

.. figure::../images.parsing/empty.png

   Conflict in Shift-Reduce Parsing

.. image:: ../images.parsing/srparser7.png 
.. image:: ../images.parsing/srparser8.png
.. image:: ../images.parsing/srparser9.png

 

.. To do: diagram showing search tree with success and failure.

Shift-reduce parsers may implement policies for resolving such
conflicts.  For example, they may address shift-reduce conflicts by
shifting only when no reductions are possible, and they may address
reduce-reduce conflicts by favouring the reduction operation that removes
the most items from the stack.  No such policies are failsafe however.

The advantages of shift-reduce parsers over recursive descent parsers
is that they only build structure that corresponds to the words in the
input.  Furthermore, they only build each substructure once,
e.g. ``NP(Det(the), N(man))`` is only built and pushed onto the stack
a single time, regardless of whether it will later be used by the ``V``
|rarr| ``V NP PP`` reduction or the ``NP`` |rarr| ``NP PP`` reduction.

The Shift Reduce Parser in NLTK
-------------------------------

The ``nltk_lite.parse`` module defines ``ShiftReduce``, a simple
implementation of a bottom-up shift-reduce parser.
Since this parser does not implement any backtracking, it is not
guaranteed to find a parse for a text, even if one exists.
Furthermore, it will only find at most one parse, even if more
parses exist.

Shift reduce parsers are created from ``Grammars`` by the
``ShiftReduceParse`` constructor.  The constructor takes an optional
parameter ``trace``.  As with the recursive descent parser, this value
specifies how verbosely the parser should describe the steps that it
takes as it parses a text:: 

  >>> sr_parse = parse.ShiftReduce(grammar)

The following example shows the trace output generated by
``sr_parser`` on a simple sentence: 

  >>> sent = list(tokenize.whitespace('I saw a man'))
  >>> sr_parse.trace()
  >>> sr_parse.parse(sent)
  Parsing 'I saw a man'
      [ * I saw a man]
    S [ 'I' * saw a man]
    R [ <NP> * saw a man]
    S [ <NP> 'saw' * a man]
    R [ <NP> <V> * a man]
    S [ <NP> <V> 'a' * man]
    R [ <NP> <V> <Det> * man]
    S [ <NP> <V> <Det> 'man' * ]
    R [ <NP> <V> <Det> <N> * ]
    R [ <NP> <V> <NP> * ]
    R [ <NP> <VP> * ]
    R [ <S> * ]
  (S: (NP: 'I') (VP: (V: 'saw') (NP: (Det: 'a') (N: 'man'))))

NLTK also defines a graphical demonstration tool for the
shift reduce parser::

 from nltk.draw.srparser import demo
 demo()


Problems with Shift Reduce Parser
---------------------------------

(incomplete, building bottom-up sequences that have no bearing on the grammar)

The Left Corner Parser
----------------------

A left-corner parser is a top-down parser with bottom-up filtering.
Unlike an ordinary recursive descent parser, it does not get trapped
in left-recursive productions.  Suppose `X` is a non-terminal that
expands to some sequence `Y`:subscript:`1` |cdots| `Y`:subscript:`n`
of terminals and non-terminals.  We call `Y`:subscript:`1` the
*left-corner* of `X`.

Before starting its work, a left-corner parser preprocesses the
context-free grammar to build a table where each row contains two
cells, the first holding a non-terminal, and the second holding the
collection of possible left-corners of that non-terminal.

Each time a production is considered by the parser, it checks that the
next input word is compatible with at least one of the pre-terminal
categories in the left-corner table.

Exercises
---------

#. **Left-corner parser:** Develop a left-corner parser (inheriting from
   ``ParseI``), based on the recursive descent parser.

#. Compare the performance of the top-down, bottom-up, and left-corner
   parsers using the same grammar and three grammatical test
   sentences. Use ``time.time()`` to log the amount of time each
   parser takes on the same sentence.  Write a function which runs all
   three parsers on all three sentences, and prints a 3-by-3 grid of
   times, as well as row and column totals. Discuss your findings.

------------
More Grammar
------------

Lexical heads other than ``V`` can be subcategorized for particular complements:

*Nouns*
   #. The rumour **that Kim was bald** circulated widely.
   #. \*The picture **that Kim was bald** circulated widely.
*Adjectives*
   #. Lee was afraid **to leave**.
   #. \*Lee was tall **to leave**.

It has also been suggested that 'ordinary' prepositions are
transitive, and that many so-called adverb are in fact intransitive
prepositions. For example, *towards* requires an ``NP`` complement,
while *home* and *forwards* forbid them.


#. Lee ran towards the house.
#. \*Lee ran towards.

#. Sammy walked home.
#. \*Sammy walked home the house.

#. Brent stepped one pace forwards.
#. \*Brent stepped one pace forwards the house.

Adopting this approach, we can also analyse certain prepositions as
allowing ``PP`` complements:

#. Kim ran away **from the house**.
#. Lee jumped down **into the boat**.

In general, the lexical categories ``V``, ``N``, ``A`` and ``P`` are
taken to be the heads of the respective phrases ``VP``, ``NP``,
``AP`` and ``PP``. Abstracting over the identity of these phrases, we
can say that a lexical category ``X`` is the head of its immediate
``XP`` phrase, and moreover that the complements `C`:subscript:`1` ... `C`:subscript:`n` of
``X`` will occur as sisters of ``X`` within that ``XP``. This is
illustrated in the following schema:

.. figure:: ../images.parsing/xp.png
   :scale: 75

We have argued that lexical categories need to be subdivided into
subcategories to account for the fact that different lexical items
select different sequences of following complements. That is, it is a
distinguishing property of complements that they co-occur with some
lexical items but not others. By contrast, :dt:`modifiers` can
occur with pretty much any instance of the relevant lexical class. For
example, consider the temporal adverbial *last Thursday*:

#. The woman gave the telescope to the dog last Thursday.
#. The woman saw a man last Thursday.
#. The dog barked last Thursday.

Moreover, modifiers are always optional, whereas complements are at
least sometimes obligatory. We can use the phrase structure
geometry to draw a structural distinction between complements, which
occur as sisters of the lexical head, versus modifiers, which occur as
sisters of the phrase which encloses the head:

.. figure:: ../images.parsing/xp-mod.png
   :scale: 75

Exercises
---------

#. Pick some of the syntactic constructions described in any
   introductory syntax text (e.g. Jurafsky and Martin, Chapter 9) and
   create a set of 15 sentences.  Five sentences should be unambiguous
   (have a unique parse), five should be ambiguous, and a further five
   should be ungrammatical.

  a) Develop a small grammar, consisting of about ten syntactic
     productions, to account for this data.  Refine your set of sentences
     as needed to test and demonstrate the grammar.  Write a function
     to demonstrate your grammar on three sentences: (i) a
     sentence having exactly one parse; (ii) a sentence having more than
     one parse; (iii) a sentence having no parses.  Discuss your
     observations using inline comments.

  b) Create a list ``words`` of all the words in your lexicon, and use
     ``random.choice(words)`` to generate sequences of 5-10 randomly
     selected words.  Does this generate any grammatical sentences which
     your grammar rejects, or any ungrammatical sentences which your
     grammar accepts?  Now use this information to help you improve your
     grammar.  Discuss your findings.


----------
Conclusion
----------


In this chapter, we only consider very small ('toy') context-free
grammars, in order to illustrate the key aspects of parsing such
grammars. But there is an obvious question as to whether the general
approach can be scaled up to cover large corpora of natural
languages. How hard would it be to construct such a set of productions by
hand? In general, the answer is: Very hard. Even if we allow ourselves
to use various formal devices that give much more succinct
representations of grammar productions (some of which will be
discussed in the next chapter), it is still extremely difficult to
keep control of the complex interactions between the many productions
required to cover the major constructions of a language. That is, it
is hard to modularize grammars, so that one portion can be worked on
independently of the other parts. This in turn means that it is
difficult to distribute the task of grammar writing across a team of
linguists. Another difficulty is that as the grammar expands to cover
a wider and wider range of constructions, there is a corresponding
increase in the number of analyses which are admitted for any one
sentence. In other words, ambiguity increases proportionally with
coverage.

.. 
 that w a broad coverage grammar
 . But we may want to ask how
 Shortcomings of this approach: unreliable, doesn't scale,
 complex interactions amongst productions makes manual debugging
 almost impossible.  Consequently linguists are unable to
 work with large-coverage grammars.-->


Despite the problems just alluded to, there are a number of
large-scale collaborative projects ongoing which appear to have
achieved interesting and often impressive results in developing
rule-based grammars for several languages. Examples are the Lexical
Functional Grammar (LFG) Pargram project
(http://www2.parc.com/istl/groups/nltt/pargram/), the Head-Driven
Phrase Structure Grammar (HPSG) LinGO Matrix framework
(http://www.delph-in.net/matrix/), and the Lexicalized Tree Adjoining
Grammar XTAG Project (http://www.cis.upenn.edu/~xtag/).

---------------
Further Reading
---------------

McCawley (1998) *The Syntactic Phenomena of English*.
Chicago University Press.

Rodney D. Huddleston, Geoffrey K. Pullum (2002).
*The Cambridge Grammar of the English Language*.
Cambridge University Press.

----

NLTK_

.. _NLTK: http://nltk.sourceforge.net/


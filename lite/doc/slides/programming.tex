% for slides
\documentclass[handout]{beamer}

% for handout
% \documentclass[handout]{beamer}
% \usepackage{pgfpages}
% \pgfpagesuselayout{4 on 1}[a4paper,landscape,scale=0.9]

\mode<handout>
{
  \usetheme{default}
  \usepackage{fullpage}
  \usepackage{pgf}
  \usepackage{hyperref}
  \setjobnamebeamerversion{programming.beamer}
}

\mode<article>
{
  \usepackage{fullpage}
  \usepackage{pgf}
  \usepackage{hyperref}
  \setjobnamebeamerversion{programming.beamer}
}

\mode<presentation>
{
  \usetheme{Warsaw}
  \setbeamercovered{transparent}
  % If you wish to uncover everything in a step-wise fashion, uncomment
  % the following command: 
  \beamerdefaultoverlayspecification{<+->}

}


\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{alltt}

\title{Programming Fundamentals and Python}

\author{Steven Bird \and Edward Loper \and Ewan Klein}
\institute{
  University of Melbourne, AUSTRALIA
  \and
  University of Pennsylvania, USA
  \and
  University of Edinburgh, UK
}

\date{\today}

\subject{Natural Language Toolkit}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\section{Introduction: Programming Basics}

\begin{frame}
  \titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
    \item non-technical overview
    \item many working program fragments
    \item try them for yourself as we go along
    \item many online tutorials (see \url{www.python.org})
    \item Textbook: Zelle, John (2004) \textit{Python Programming: An Introduction
        to Computer Science}
  \end{itemize}
\end{frame}

\subsection{Lists}

\begin{frame}[fragile]
  \frametitle{Defining Lists}
  \small

\begin{itemize}
\item list: ordered sequence of items
\item item: string, number, complex object (e.g. a list)
\item list representation: comma separated items: \verb|['John', 14, 'Sep', 1984]|
\item list initialization:

\begin{verbatim}
    >>> a = ['colourless', 'green', 'ideas']
\end{verbatim}

\item sets the value of variable \texttt{a}
\item to see the its value, do: \texttt{print a}
\item in interactive mode, just type the variable name:

\begin{verbatim}
  >>> a
  ['colourless', 'green', 'ideas']
\end{verbatim}
\end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Simple List Operations}
  \small

\begin{enumerate}
\item length: \texttt{len()}
\item indexing: \texttt{a[0]}, \texttt{a[1]}
\item indexing from right: \texttt{a[-1]}
\item slices: \texttt{a[1:3]}, \texttt{a[-2:]}
\item concatenation: \texttt{b = a + ['sleep', 'furiously']}
\item sorting: \texttt{b.sort()}
\item reversing: \texttt{b.reverse()}
\item iteration: \texttt{for item in a:}
\item all the above applies to strings as well
\item double indexing: \texttt{b[2][1]}
\item finding index: \texttt{b.index('green')}
\end{enumerate}
\end{frame}

\subsection{Strings}

\begin{frame}
  \frametitle{Simple String Operations}
  \small

\begin{enumerate}
\item joining: \texttt{c = ' '.join(b)}
\item splitting: \texttt{c.split('r')}
\item lambda expressions: \texttt{lambda x: len(x)}
\item maps: \texttt{map(lambda x: len(x), b)}
\item list comprehensions: \texttt{[(x, len(x)) for x in b]}
\item getting help: \texttt{help(list)}, \texttt{help(str)}
\end{enumerate}
\end{frame}

\subsection{Dictionaries}

\begin{frame}[fragile]
  \frametitle{Dictionaries}
  \small

\begin{itemize}
\item accessing items by their names, e.g. dictionary
\item defining entries:

\begin{verbatim}
  >>> d = {}
  >>> d['colourless'] = 'adj'
  >>> d['furiously'] = 'adv'
  >>> d['ideas'] = 'n'
\end{verbatim}

\item accessing:

\begin{verbatim}
  >>> d.keys()
  ['furiously', 'colourless', 'ideas']
  >>> d['ideas']
  'n'
  >>> d
  {'furiously': 'adv', 'colourless': 'adj', 'ideas': 'n'}
\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Dictionaries: Iteration}

\begin{verbatim}
  >>> for w in d:
  ...    print "%s [%s]," % (w, d[w]),
  furiously [adv], colourless [adj], ideas [n],
\end{verbatim}

\begin{itemize}
\item rule of thumb: dictionary entries are like variable names
\item \textit{create} them by assigning to them\\
  \verb|x = 2| (variable), \verb|d['x'] = 2| (dictionary entry)
\item \textit{access} them by reference\\
  \verb|print x| (variable), \verb|print d['x']| (dictionary entry)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Dictionaries: Example: Counting Word Occurrences}
\small

\begin{verbatim}
  >>> from nltk_lite.corpora import gutenberg
  >>> count = {}
  >>> for word in gutenberg.raw('shakespeare-macbeth'):
  ...     word = word.lower()
  ...     if word not in count:
  ...         count[word] = 0
  ...     count[word] += 1
\end{verbatim}

Now inspect the dictionary:

\begin{verbatim}
  >>> print count['scotland']
  12
  >>> frequencies = [(freq, word) for (word, freq) in count.items()]
  >>> frequencies.sort()
  >>> frequencies.reverse()
  >>> print frequencies[:20]
  [(1986, ','), (1245, '.'), (692, 'the'), (654, "'"), (567, 'and'), (482, ':'), (399, 'to'), (365, 'of'), (360, 'i'), (255, 'a'), (246, 'that'), (242, '?'), (224, 'd'), (218, 'you'), (213, 'in'), (207, 'my'), (198, 'is'), (170, 'not'), (165, 'it'), (156, 'with')]
\end{verbatim}
\end{frame}

\section{Regular Expressions}

\subsection{Introduction}

\begin{frame}
\frametitle{Regular Expressions}
\begin{itemize}
\item string matching
\item substitution
\item patterns, classes
\item Python's regular expression module: \texttt{re}
\item NLTK's utility function: \texttt{re\_show}
\end{itemize}
\end{frame}

\subsection{Matching and Substituting}

\begin{frame}[fragile]
\frametitle{Loading module, Matching}

\begin{itemize}
\item Set up:

\begin{verbatim}
  >>> import re
  >>> from nltk_lite.utilities import re_show
  >>> sent = "colourless green ideas sleep furiously"
\end{verbatim}

\item Matching:

\begin{verbatim}
  >>> re_show('l', sent)
  co{l}our{l}ess green ideas s{l}eep furious{l}y
  >>> re_show('green', sent)
  colourless {green} ideas sleep furiously
\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Substitutions}

\begin{itemize}
\item E.g. replace all instances of \texttt{l} with \texttt{s}.
\item Creates an output string (doesn't modify input)

\begin{verbatim}
  >>> re.sub('l', 's', sent)
  'cosoursess green ideas sseep furioussy'
\end{verbatim}

\item Work on substrings (NB not words)

\begin{verbatim}
  >>> re.sub('green', 'red', sent)
  'colourless red ideas sleep furiously'
\end{verbatim}
\end{itemize}
\end{frame}

\subsection{More Complex Patterns}

\begin{frame}[fragile]
\frametitle{More Complex Patterns}

\begin{itemize}
\item Disjunction:

\begin{verbatim}
  >>> re_show('(green|sleep)', sent)
  colourless {green} ideas {sleep} furiously
  >>> re.findall('(green|sleep)', sent)
  ['green', 'sleep']
\end{verbatim}

\item Character classes, e.g. non-vowels followed by vowels:

\begin{verbatim}
  >>> re_show('[^aeiou][aeiou]', sent)
  {co}{lo}ur{le}ss g{re}en{ i}{de}as s{le}ep {fu}{ri}ously
  >>> re.findall('[^aeiou][aeiou]', sent)
  ['co', 'lo', 'le', 're', ' i', 'de', 'le', 'fu', 'ri']
\end{verbatim}
\end{itemize}
\end{frame}

\subsection{Structured Results}

\begin{frame}[fragile]
\frametitle{Structured Results}
\begin{itemize}
\item Select a sub-part to be returned
\item e.g. non-vowel characters which appear before a vowel:

\begin{verbatim}
  >>> re.findall('([^aeiou])[aeiou]', sent)
  ['c', 'l', 'l', 'r', ' ', 'd', 'l', 'f', 'r']
\end{verbatim}

\item generate \textit{tuples}, for later tabulation

\begin{verbatim}
  >>> re.findall('([^aeiou])([aeiou])', sent)
  [('c', 'o'), ('l', 'o'), ('l', 'e'), ('r', 'e'), (' ', 'i'), ('d', 'e'), ('l', 'e'), ('f', 'u'), ('r', 'i')]
\end{verbatim}
\end{itemize}
\end{frame}

\section{Accessing Data and Programs}

\subsection{Accessing Files}

\begin{frame}[fragile]
\frametitle{Accessing Files and the Web}
\begin{itemize}
\item accessing local files (create \texttt{corpus.txt} first)

\begin{verbatim}
  >>> print open('corpus.txt').read() 
  Hello world.  This is a test file.
\end{verbatim}

\item Accessing URLs on the Web:

\begin{verbatim}
  >>> from urllib import urlopen
  >>> page = urlopen("http://news.bbc.co.uk/").read()
  >>> page = re.sub('<[^>]*>', '', page)
  >>> page = re.sub('\s+', ' ', page)
  >>> print page[:60]
   BBC NEWS | News Front Page News Sport Weather World Service
\end{verbatim}
\end{itemize}
\end{frame}

\subsection{Accessing NLTK}

\begin{frame}[fragile]
\frametitle{Accessing NLTK}

\begin{itemize}
\item modules: classes, functions
\item data structures, algorithms
\item importing, e.g. \texttt{from nltk\_lite.utilities import *}
\item conflicts
\item explicit naming: \texttt{from nltk\_lite.utilities import re\_show}
\item higher level module import:

\begin{verbatim}
  >>> from nltk_lite import utilities
  >>> utilities.re_show('green', s)
  colourless {green} ideas sleep furiously
\end{verbatim}
\end{itemize}
\end{frame}

\subsection{Accessing Corpora}

\begin{frame}[fragile]
\frametitle{Texts from Project Gutenberg}

\begin{verbatim}
  >>> from nltk_lite.corpora import gutenberg
  >>> gutenberg.items
  ['austen-emma', 'austen-persuasion', 'austen-sense', 'bible-kjv', 'blake-poems', 'blake-songs', 'chesterton-ball', 'chesterton-brown', 'chesterton-thursday', 'milton-paradise', 'shakespeare-caesar', 'shakespeare-hamlet', 'shakespeare-macbeth', 'whitman-leaves']
  >>> count = 0
  >>> for word in gutenberg.raw('whitman-leaves'):
  ...     count += 1
  >>> print count
  154873
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Brown Corpus}
\small

\begin{verbatim}
  >>> from nltk_lite.corpora import brown
  >>> brown.items
  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'r']
  >>> from nltk_lite.corpora import extract
  >>> print extract(0, brown.raw())
  ['The', 'Fulton', 'County', 'Grand', 'Jury', 'said', 'Friday', 'an', 'investigation', 'of', "Atlanta's", 'recent', 'primary', 'election', 'produced', '``', 'no', 'evidence', "''", 'that', 'any', 'irregularities', 'took', 'place', '.']
  >>> print extract(0, brown.tagged())
  [('The', 'at'), ('Fulton', 'np-tl'), ('County', 'nn-tl'), ('Grand', 'jj-tl'), ('Jury', 'nn-tl'), ('said', 'vbd'), ('Friday', 'nr'), ('an', 'at'), ('investigation', 'nn'), ('of', 'in'), ("Atlanta's", 'np$'), ('recent', 'jj'), ('primary', 'nn'), ('election', 'nn'), ('produced', 'vbd'), ('``', '``'), ('no', 'at'), ('evidence', 'nn'), ("''", "''"), ('that', 'cs'), ('any', 'dti'), ('irregularities', 'nns'), ('took', 'vbd'), ('place', 'nn'), ('.', '.')]
\end{verbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{Penn Treebank}
\small

\begin{verbatim}
  >>> from nltk_lite.corpora import treebank
  >>> print extract(0, treebank.parsed())
  (S:
    (NP-SBJ:
      (NP: (NNP: 'Pierre') (NNP: 'Vinken'))
      (,: ',')
      (ADJP: (NP: (CD: '61') (NNS: 'years')) (JJ: 'old'))
      (,: ','))
    (VP:
      (MD: 'will')
      (VP:
        (VB: 'join')
        (NP: (DT: 'the') (NN: 'board'))
        (PP-CLR:
          (IN: 'as')
          (NP: (DT: 'a') (JJ: 'nonexecutive') (NN: 'director')))
        (NP-TMP: (NNP: 'Nov.') (CD: '29'))))
    (.: '.'))
\end{verbatim}
\end{frame}

\section{Program Development}

\begin{frame}
\frametitle{Program Development}
\begin{itemize}
\item High-level Design
\item Algorithm Design
\item Structured Programming
\item Debugging
\item Performance Tuning
\end{itemize}
\end{frame}

\subsection{Defining Functions and Modules}

\begin{frame}[fragile]
\frametitle{Defining Functions}
\scriptsize
\begin{itemize}
\item part of a program needs to be used several times over
\item e.g. form plural of singular noun, to be done in several places
  in a program
\item localize this work inside a \textit{function}
\item also helps readability, reusability

\begin{verbatim}
  >>> def plural(word):
  ...     if word[-1] == 'y':
  ...         return word[:-1] + 'ies'
  ...     elif word[-1] in 'sx':
  ...         return word + 'es'
  ...     elif word[-2:] in ['sh', 'ch']:
  ...         return word + 'es'
  ...     elif word[-2:] == 'an':
  ...         return word[:-2] + 'en'
  ...     return word + 's'
  >>> plural('fairy')
  'fairies'
  >>> plural('woman')
  'women'
\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Defining Modules}

\begin{verbatim}
def parsed(files):
    for file in files:
        path = os.path.join(get_basedir(), "treebank", file)
        s = open(path).read()
        for t in tokenize.blankline(s):
            yield tree.bracket_parse(t)
\end{verbatim}
\end{frame}

\subsection{Algorithm Design}

\begin{frame}
  \frametitle{Algorithm Design}
  \small

  \begin{itemize}
  \item \textit{algorithm}: a "recipe" for solving a problem
  \item e.g. to multiply 16 by 12 we might use any of the following methods:

    \begin{enumerate}
    \item Add 16 to itself 12 times over
    \item Perform "long multiplication", starting with the least-significant
      digits of both numbers
    \item Look up a multiplication table
    \item Repeatedly halve the first number and double the second,
      16*12 = 8*24 = 4*48 = 2*96 = 192
    \item Do 10*12 to get 120, then add 6*12
    \end{enumerate}

  \item computation time, intermediate storage
  \item brute-force, divide-and-conquer, dynamic programming, greedy search
  \item Textbook: Levitin, Anany (2003) \textit{Introduction to the Design and
      Analysis of Algorithms}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sorting Algorithms}

\begin{itemize}
\item Many algorithms for sorting
\item Illustrates the difference in algorithm complexity

\begin{verbatim}
  >>> from random import shuffle
  >>> from nltk_lite.misc import sort
  >>> a = range(1000)
  >>> shuffle(a); sort.bubble(a)
  250918
  >>> shuffle(a); sort.merge(a)
  6175
  >>> shuffle(a); sort.quick(a)
  2378
\end{verbatim}
\end{itemize}
\end{frame}

\subsection{Top-Down Design}

\begin{frame}
\frametitle{Top-Down Design}
\begin{itemize}
\item Break down high-level task into manageable components
\item Build and test each component
\item Assemble them into a complex system
\item Example: identify adjective-noun collocations in text
  \begin{enumerate}
  \item read in the corpus
  \item count events (each adjective, noun, adj-noun combination)
  \item compute $\chi^2$ statistics
  \item sort adj-noun pairs in decreasing order
  \item output $n$-most significant collocations
  \end{enumerate}
\item what are the inputs and outputs of each step (i.e. \textit{interfaces})
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Top-Down Design (cont)}

\begin{enumerate}
\item Define top-level function:

\begin{verbatim}
def colloc(corpus_name, num):
    corpus = load_corpus(corpus_name)
    a_counts, n_counts, a_n_counts = count(corpus, 'JJ', 'NN')
    a_n_scores = chisq(a_counts, n_counts, a_n_counts)
    a_n_ranked = sort_by_score(a_n_scores)
    return a_n_ranked[:num]
\end{verbatim}

\item Iteratively define lower-level functions, e.g. \texttt{chisq()}

\item Bottom-up testing
\begin{itemize}
\item standard test cases for components, known output
\item only assemble once each component is known to work correctly
  on the test cases
\end{itemize}
\end{enumerate}
\end{frame}

\subsection{Debugging}

\begin{frame}
  \frametitle{Debugging}

  \begin{itemize}
  \item What's in the name:
    \begin{itemize}
    \item problems are small relative to their impact
    \item hard-to-find
    \item seem to take on a life of their own as the programmer tries to
      hunt them down
    \end{itemize}
  \item steps:
    \begin{itemize}
    \item isolate the problem
    \item syntax error: see error messages, linked to line numbers
    \item run-time error: \textit{stack-trace}
    \item add diagnostic print statements
    \item display values of variables just before problem
    \item Python debugger: \texttt{pdb}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Next Steps...}

\begin{frame}
\frametitle{Next Steps: Learning to Program}
\begin{itemize}
\item experimental
\item Python's \texttt{help} and \texttt{dir} commands
\item tutorial exercises
\end{itemize}
\end{frame}

\end{document}

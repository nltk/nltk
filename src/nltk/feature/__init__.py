# Natural Language Toolkit: Feature Extraction
#
# Copyright (C) 2001 University of Pennsylvania
# Author: Edward Loper <edloper@gradient.cis.upenn.edu>
# URL: <http://nltk.sf.net>
# For license information, see LICENSE.TXT
#
# $Id$

# [XX] This comment is out-dated:
"""
Classes and interfaces for finding a token's X{features}, or specific
pieces of information about the token.  These features are encoded in
a uniform representation, usually as booleans, integers, or floating
point numbers.  This task is known as X{feature extraction} or
X{feature detection}.

A X{feature extractor} defines an ordered sequence of X{features}.
Each feature's index in this sequence serves a unique identifier for
that features, known as its C{feature id}.

When a feature extractor is applied to a token, it creates a sequence
of feature values corresponding to the extractor's features.  In
particular, the M{i}th element of this feature value sequence is the
value for the M{i}th feature.  This sequence of feature values is
encoded using implenentaitons of L{FeatureValueListI}, which defines
methods for both sparse and dense access to feature values.

L{FeatureExtractorI} defines a standard interface for feature
extractors.
"""

from nltk.token import *
from nltk.util import *

######################################################################
## Feature Detection
######################################################################

class FeatureDetectorI:
    """
    A processing class for finding the values of one or more features
    for a token.  These features are stored in the C{FEATURES}
    property, which contains a dictionary mapping from feature names
    to feature values.  
    """
    def features(self):
        """
        @return: A list of the names of the features that can be
        generated by this feature detector.
        @rtype: C{list} of C{string}
       """
        raise NotImplementedError
    
    def detect_features(self, token):
        """
        Find the values of this detector's features for C{token}, and
        add them to the token's C{FEATURES} dictionary.  If the
        C{FEATURES} dictionary does not exist, then it is created.
        Any values for this detector's features that are already
        present in the C{FEATURES} dictionary will be overwritten; but
        any other features will not be modified.
        
        @param token: The token whose features should be found.
        @type token: L{Token}
        @outprop: L{FEATURES}
        """
        raise NotImplementedError

    def raw_detect_features(self, token):
        """
        Find the values of this detector's features for C{token}, and
        return them as a dictionary from feature names to feature
        values.
        
        @param token: The token whose features should be found.
        @type token: L{Token}
        @rtype: C{dict} from C{string} to C{*}
        """
        raise NotImplementedError
        
class AbstractFeatureDetector(FeatureDetectorI):
    """
    An abstract base class for feature detectors.
    C{AbstractFeatureDetector} provides a default implementation for
    L{detect_features} (based on C{raw_detect_features}).
    """
    def __init__(self, **property_names):
        self._property_names = property_names
        
    def property(self, name):
        return self._property_names.get(name, name)
    
    def detect_features(self, token):
        FEATURES = self.property('FEATURES')

        # Initialize FEATURES to {}, if it doesn't exist.
        if not token.has(FEATURES):
            token[FEATURES] = {}

        # Update FEATURES with the token's features (as given by
        # raw_detect_features).
        features = self.raw_detect_features(token)
        token[FEATURES].update(features)

class PropertyFeatureDetector(AbstractFeatureDetector):
    def __init__(self, *properties, **property_names):
        self._properties = properties
        AbstractFeatureDetector.__init__(self, **property_names)
    def features(self):
        return self._properties
    def raw_detect_features(self, token):
        return dict([(p,token[p]) for p in self._properties])


######################################################################
## Feature Encoding
######################################################################

class FeatureEncoderI:
    """

    A processing class for encoding a token's feature dictionary in a
    homogenous format, suitable for use with machine learning
    algorithms.
    
    @outprop: ENCODED_FEATURES
    """
    def encode_features(self, token):
        """
        """
        raise NotImplementedError

    def features_encoded(self):
        """
        @return: A list of features that this encoder encodes.
        """
        raise NotImplementedError

class AbstractFeatureEncoder(FeatureEncoderI):
    def __init__(self, **property_names):
        self._property_names = property_names

    def property(self, name):
        return self._property_names.get(name, name)

    def encode_features(self, token):
        FEATURES = self.property('FEATURES')
        token[FEATURES] = self.raw_encode_features(token)

# Merges encoders for individual features:
class MergedSparseListFeatureEncoder(AbstractFeatureEncoder):
    def __init__(self, encoders, **property_names):
        self._encoders = encoders
        # [XX] check that all encoders have the same type??
        AbstractFeatureEncoder.__init__(self, **property_names)

    def register(self, token):
        for encoder in self._encoders:
            encoder.register(token)

    def freeze(self):
        for encoder in self._encoders:
            encoder.freeze()

    def raw_encode_features(self, token):
        encoded_fvlist = self._encoders[0].encode_features(token)
        for encoder in self._encoders[1:]:
            encoded_fvlist += encoder.raw_encode_features(token)
        return encoded_fvlist

class AutoSparseListFeatureEncoder(AbstractFeatureEncoder):
    def __init__(self, initial_encoders={}, count=False,
                 **property_names):
        """
        @type initial_encoders: C{dict} from C{string} to
            L{FeatureEncoderI}
        """
        self._count = count
        self._encoders = initial_encoders.copy()
        self._features = initial_encoders.keys()
        AbstractFeatureEncoder.__init__(self, **property_names)

    def register(self, token):
        FEATURES = self.property('FEATURES')
        for (fname, fval) in token[FEATURES].items():
            if fname in self._encoders:
                encoder = self._encoders[fname]
            else:
                encoder = SparseListFeatureEncoder(fname, count=self._count)
                self._encoders[fname] = encoder
                self._features.append(fname)
            if not encoder.frozen():
                encoder.register(token)

    def freeze(self):
        for encoder in self._encoders.values():
            if not encoder.frozen():
                encoder.freeze()

    def raw_encode_features(self, token):
        FEATURES = self.property('FEATURES')

        # Initialize the output sparse list.
        if self._count: encoded_fvlist = SparseList({}, 0, 0)
        else: encoded_fvlist = SparseList({}, 0, False)

        # Run each of the encoders.
        for fname in self._features:
            encoder = self._encoders[fname]
            encoded_fvlist += encoder.raw_encode_features(token)
        return encoded_fvlist

    def description(self, fid):
        for encoder in self._encoders.values():
            if fid < encoder.num_features():
                return encoder.description(fid)
            else:
                fid -= encoder.num_features()

    def num_features(self):
        return sum([e.num_features() for e in self._encoders.values()])

    def foo(self):
        foo = []
        for encoder in self._encoders.values():
            foo += encoder.foo()
        return foo
        
class SparseListFeatureEncoder(AbstractFeatureEncoder):
    """
    A feature encoder that encodes a single feature's value as a
    sparse list over booleans or integers.  The feature must take
    either basic values, or lists or sets of basic values, where the
    X{basic values} supported by C{SparseListFeatureEncoder} are:
      - strings
      - integers
      - tuples of basic values
      
    In the sparse list generated by this encoder, each index
    corresponds to a single basic value.  The sparse list values can
    be either booleans (indicating whether the feature has or contains
    that basic value), or integers (inticating how many times the
    feature has or contains that basic value), depending on the
    constructor's C{count} parameter.

    An index is also added for unseen basic values.
    """
    def __init__(self, feature_name, range=None, count=False,
                 unknown_cutoff=0, **property_names):
        """
        @param count: Should number of occurances be counted (giving
           an int vector) or not (giving a boolean vector)?
        @param unknown_cutoff: Treat all features that were registered
            fewer than C{unknown_cutoff} times as if they're unknown.
        """
        self._property_names = property_names
        self._feature_name = feature_name
        self._count = count
        
        if range is not None:
            self._id_to_val = list(range)
            self._val_to_id = dict([(v,i) for (i,v) in enumerate(range)])
            self._len = len(range)
        else:
            self._id_to_val = []
            self._val_to_id = {}
            self._len = None # Features need to be registered

        AbstractFeatureEncoder.__init__(self, **property_names)
        
    def register(self, token):
        if self.frozen(): raise ValueError, 'already frozen'

        # Get the feature's value.
        FEATURES = self.property('FEATURES')
        feature_val = token[FEATURES][self._feature_name]

        # Register its basic value(s) with _register
        if isinstance(feature_val, (str, int, tuple)):
            self._register(feature_val)
        elif isinstance(feature_val, (list, Set)):
            for val in feature_val:
                self._register(val)
        else:
            raise ValueError('Unsupported feature value type %s' %
                             type(feature_val).__name__)

    def _register(self, feature_val):
        if feature_val not in self._val_to_id:
            self._val_to_id[feature_val] = len(self._id_to_val)
            self._id_to_val.append(feature_val)

    def freeze(self):
        if self.frozen(): raise ValueError, 'already frozen'
        self._len = len(self._id_to_val)

    def frozen(self):
        return (self._len is not None)

    def description(self, fid):
        return '%s=%s' % (self._feature_name, self._id_to_val[fid])

    def num_features(self):
        return self._len

    def foo(self):
        return ['%s=%s' % (self._feature_name, self._id_to_val[fid])
                for fid in range(self._len)]

    def raw_encode_features(self, token):
        if not self.frozen(): raise ValueError, 'must freeze first'
        FEATURES = self.property('FEATURES')
        
        if self._feature_name not in token[FEATURES]:
            return SparseList({}, self._len, False)
        
        feature_val = token[FEATURES][self._feature_name]

        # [XX] deal with unseen feature values
        if isinstance(feature_val, (str, int, tuple)):
            if self._count:
                # Basic value -> int sparse list
                assigns = {self._val_to_id[feature_val]:1}
                return SparseList(assigns, self._len, 0)
            else:
                # Basic value -> bool sparse list
                assigns = {self._val_to_id[feature_val]:True}
                return SparseList(assigns, self._len, False)
        elif isinstance(feature_val, (list, Set)):
            if self._count:
                # List/set of basic value -> int sparse list
                assigns = {}
                for v in feature_val:
                    fid = self._val_to_id[feature_val]
                    assigns[fid] = assigns.get(fid,0)+1
                return SparseList(assigns, self._len, 0)
            else:
                # List/set of basic value -> bool sparse list
                assigns = dict([(self._val_to_id[v], True)
                                for v in feature_val])
                return SparseList(assigns, self._len, False)
        else:
            raise ValueError('Unsupported feature value type %s' %
                             type(feature_val).__name__)
            


######################################################################
## Demo
######################################################################

def demo():
    import nltk.corpus
    text = nltk.corpus.brown.tokenize('cr01')
    toks = text['SUBTOKENS']
    split = len(toks) * 3/4
    train, test = toks[:split], toks[split:]
    
    detectors = [PropertyFeatureDetector('TEXT'),
                 PropertyFeatureDetector('TAG')]
    encoder = AutoSparseListFeatureEncoder()
    
    for tok in train:
        for detector in detectors:
            detector.detect_features(tok)
        encoder.register(tok)

    encoder.freeze()
    
    #print ''.join(['%8s' % s for s in encoder.foo()])

    for tok in test:
        for detector in detectors:
            detector.detect_features(tok)
        fvals = encoder.raw_encode_features(tok)
        print tok
        print ' '.join([encoder.description(fid)
                        for fid, fval in fvals.assignments()])
        #print [1*v for v in fvals]
        #print ''.join(['%8s' % s for s in fvals])
        

if __name__ == '__main__': demo()

        

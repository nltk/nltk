# Natural Language Toolkit: Chunked Corpus Reader
#
# Copyright (C) 2001-2007 University of Pennsylvania
# Author: Steven Bird <sb@ldc.upenn.edu>
#         Edward Loper <edloper@gradient.cis.upenn.edu>
# URL: <http://nltk.sf.net>
# For license information, see LICENSE.TXT

"""
Corpus reader for chunked (optionally tagged) documents.
"""

from nltk.corpus.reader.util import *
from nltk.corpus.reader.api import *
from nltk.corpus.reader.bracket_parse import BracketParseCorpusReader
from nltk.tree import Tree
from nltk import tokenize, chunk
import os.path

class ChunkedCorpusReader(CorpusReader):
    """
    Corpus reader for chunked (and optionally tagged) documents.
    """
    def __init__(self, root, items, extension='', sep='/',
                 str2chunktree=chunk.tagstr2tree,
                 sent_tokenizer=tokenize.line,
                 para_block_reader=read_blankline_block):
        """
        @param root: The root directory for this corpus.
        @param items: A list of items in this corpus.
        @param extension: File extension for items in this corpus.
        @param sep: The tag separator for tagged words.  Use C{None}
            for chunked corpora that do not contain tagged words.
        """
        self._root = root
        """The root directory for this corpus."""
        
        self._items = items
        """A list of items in this corpus."""
        
        self._extension = extension
        """File extension for items in this corpus."""

        self._cv_args = (sep, str2chunktree, sent_tokenizer,
                         para_block_reader)
        """Arguments for corpus views generated by this corpus."""

    @property
    def root(self):
        """The directory where this corpus is stored.."""
        return self._root

    @property
    def items(self):
        """A list of the documents in this corpus"""
        items = self._items
        if isinstance(items, basestring):
            items = find_corpus_items(self._root, items, self._extension)
        self.__dict__['items'] = tuple(sorted(items))
        return self.items
            
    def raw(self, items=None):
        return concat([open(filename).read()
                       for filename in self._item_filenames(items)])

    def words(self, items=None):
        return concat([ChunkedCorpusView(f, 0, 0, 0, 0, *self._cv_args)
                       for f in self._item_filenames(items)])

    def sents(self, items=None):
        return concat([ChunkedCorpusView(f, 0, 1, 0, 0, *self._cv_args)
                       for f in self._item_filenames(items)])

    def paras(self, items=None):
        return concat([ChunkedCorpusView(f, 0, 1, 1, 0, *self._cv_args)
                       for f in self._item_filenames(items)])

    def tagged_words(self, items=None):
        return concat([ChunkedCorpusView(f, 1, 0, 0, 0, *self._cv_args)
                       for f in self._item_filenames(items)])

    def tagged_sents(self, items=None):
        return concat([ChunkedCorpusView(f, 1, 1, 0, 0, *self._cv_args)
                       for f in self._item_filenames(items)])

    def tagged_paras(self, items=None):
        return concat([ChunkedCorpusView(f, 1, 1, 1, 0, *self._cv_args)
                       for f in self._item_filenames(items)])

    def chunked_words(self, items=None):
        return concat([ChunkedCorpusView(f, 1, 0, 0, 1, *self._cv_args)
                       for f in self._item_filenames(items)])

    def chunked_sents(self, items=None):
        return concat([ChunkedCorpusView(f, 1, 1, 0, 1, *self._cv_args)
                       for f in self._item_filenames(items)])

    def chunked_paras(self, items=None):
        return concat([ChunkedCorpusView(f, 1, 1, 1, 1, *self._cv_args)
                       for f in self._item_filenames(items)])

    def _item_filenames(self, items):
        if items is None: items = self.items
        if isinstance(items, basestring): items = [items]
        return [os.path.join(self._root, '%s%s' % (item, self._extension))
                for item in items]
        
    def _read_block(self, stream):
        return [chunk.tagstr2tree(t) for t in
                read_blankline_block(stream)]

class ChunkedCorpusView(StreamBackedCorpusView):
    def __init__(self, filename, tagged, group_by_sent, group_by_para,
                 chunked, sep, str2chunktree, sent_tokenizer,
                 para_block_reader):
        StreamBackedCorpusView.__init__(self, filename)
        self._tagged = tagged
        self._group_by_sent = group_by_sent
        self._group_by_para = group_by_para
        self._chunked = chunked
        self._sep = sep
        self._str2chunktree = str2chunktree
        self._sent_tokenizer = sent_tokenizer
        self._para_block_reader = para_block_reader
        # Decide what to do for non-tagged corpora.
        if sep is None and self._chunked:
            self._tagged = False
        if sep is None and self._tagged:
            raise ValueError('This corpus does not contain tags!')

    def read_block(self, stream):
        block = []
        for para_str in self._para_block_reader(stream):
            para = []
            for sent_str in self._sent_tokenizer(para_str):
                sent = self._str2chunktree(sent_str)
                
                # If requested, throw away the tags.
                if not self._tagged:
                    sent = self._untag(sent)

                # If requested, throw away the chunks.
                if not self._chunked:
                    sent = sent.leaves()

                # Add the sentence to `para`.
                if self._group_by_sent:
                    para.append(sent)
                else:
                    para.extend(sent)
                    
            # Add the paragraph to `block`.
            if self._group_by_para:
                block.append(para)
            else:
                block.extend(para)
                
        # Return the block
        return block

    def _untag(self, tree):
        for i, child in enumerate(tree):
            if isinstance(child, Tree):
                self._untag(child)
            elif isinstance(child, tuple):
                tree[i] = child[0]
            else:
                raise ValueError('expected child to be Tree or tuple')
        return tree
    
######################################################################
#{ Demo
######################################################################
def demo():
    pass

if __name__ == '__main__':
    demo()



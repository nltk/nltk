====================================
Logical Inference and Model Building
====================================

------------
Introduction
------------

Within the area of automated reasoning, first order theorem proving
and model building (or model generation) have both received much
attention, and have given rise to highly sophisticated techniques. We
focus therefore on providing an NLTK interface to third party tools
for these tasks.  In particular, the module ``nltk_contrib.inference`` can be
used to access both theorem provers and model builders.

---------------------------------
NLTK Interface to Theorem Provers
---------------------------------

The ``nltk_contrib.inference`` module contains a method
``get_prover()`` that takes a proof goal and optionally, the name of a
theorem prover.  The default is ``'Prover9'``, but the tableau prover
may be used by specifying ``'tableau'``. The proof goal needs to be an
instance of the ``Expression`` class specified by ``nltk.sem.logic``.
In the following example, the proof goal is a biconditional.

    >>> from nltk_contrib.inference import *
    >>> from nltk.sem import LogicParser, ApplicationExpression, Operator
    >>> lp = LogicParser()
    >>> bicond = lp.parse('(some x.((man x) and (walks x)) iff some x.((walks x) and (man x)))')
    >>> get_prover(bicond, prover_name='tableau').prove()
    True
    >>> get_prover(bicond, prover_name='Prover9').prove()
    True


-------
Prover9
-------

Prover9 Installation
~~~~~~~~~~~~~~~~~~~~

You can download Prover9 from http://www.cs.unm.edu/~mccune/prover9/.

Extract the source code into a suitable directory and follow the
instructions in the Prover9 ``README.make`` file to compile the executables.
Install these into an appropriate location; the
``prover9_search`` variable is currently configured to look in the
following locations::

    ['.', '/usr/local/bin/prover9', '/usr/local/bin/prover9/bin',
    '/usr/local/bin', '/usr/bin', '/usr/local/prover9',
    '/usr/local/share/prover9']

    
Using Prover9
~~~~~~~~~~~~~

The general case in theorem proving is to determine whether ``S |- g``
holds, where ``S`` is a possibly empty set of assumptions, and ``g``
is a proof goal.

As mentioned earlier, NLTK input to ``Prover9`` must be
``Expression``\ s of ``nltk.sem.logic``. A ``Prover9`` instance is
initialized with a proof goal and, possibly, some assumptions. The
``prove()`` method attempts to find a proof of the goal, given the
list of assumptions (in this case, none).

    >>> goal = LogicParser().parse('((man x) iff (not (not (man x))))')
    >>> prover = Prover9(goal)
    >>> prover.prove()
    True

We can also call the ``prove()`` method directly on the goal:

    >>> goal = LogicParser().parse('all x. ((man x) implies (man x))')
    >>> print Prover9(goal).prove()
    True
    
Given a ``Prover9`` instance ``prover``, the method
``prover.show_proof()`` will print out the extensive proof information
provided by Prover9, shown in abbreviated form here::

    ============================== Prover9 ===============================
    Prover9 (32) version Dec-2007, Dec 2007.
    Process 6317 was started by ewan on isalpha.local,
    Mon Jan 21 15:23:28 2008
    The command was "/usr/local/bin/prover9 -f /var/...

    ============================== end of head ===========================
    <BLANKLINE>
    ============================== INPUT =================================
    <BLANKLINE>
    % Reading from file /var/...
    <BLANKLINE>
    <BLANKLINE>
    formulas(goals).
    (all x (man(x) -> man(x))).
    end_of_list.

    ...
    ============================== end of search =========================
    <BLANKLINE>
    THEOREM PROVED
    <BLANKLINE>
    Exiting with 1 proof.
    <BLANKLINE>
    Process 6317 exit (max_proofs) Mon Jan 21 15:23:28 2008


As mentioned earlier, we may want to list some assumptions for
the proof, as shown here.

    >>> g = LogicParser().parse('(mortal socrates)')
    >>> a1 = LogicParser().parse('all x.((man x) implies (mortal x))')
    >>> prover = Prover9(g, assumptions=[a1])
    >>> prover.assumptions()
    all x.((man x) implies (mortal x))

However, the assumptions are not sufficient to derive the goal:

    >>> print prover.prove()
    False

So let's add another assumption:

    >>> a2 = LogicParser().parse('(man socrates)')    
    >>> prover.add_assumptions([a2])
    >>> prover.assumptions()
    all x.((man x) implies (mortal x))
    (man socrates)
    >>> print prover.prove()
    True

We can also show the assumptions in ``Prover9`` format.

    >>> prover.assumptions(output_format='Prover9')
    all x (man(x) -> mortal(x))
    man(socrates)

    >>> prover.assumptions(output_format='Spass')
    Traceback (most recent call last):
      . . .
    NameError: Unrecognized value for 'output_format': Spass

Assumptions can be retracted from the list of assumptions.

    >>> prover.retract_assumptions([a1])
    >>> prover.assumptions()
    (man socrates)
    >>> prover.retract_assumptions([a1])

Statements can be loaded from a file and parsed. We can then add these
statements as new assumptions.

    >>> g = LogicParser().parse('all x. ((boxer1 x) implies (not (boxer2 x)))')
    >>> prover = Prover9(g)
    >>> prover.prove()
    False
    >>> new = prover.load('onto1.fol')
    >>> for a in new:
    ...     print a.infixify()
    all x.((boxer2 x) implies (dog x))
    all x.((boxer1 x) implies (person x))
    all x.(not ((dog x) and (person x)))
    all x.(not ((kitchen x) and (garden x)))
    all x.((kitchen x) implies (location x))
    all x.((garden x) implies (location x))
    >>> prover.add_assumptions(new)
    >>> print prover.prove()
    True


------------
DRS Equality
------------

One application of the theorem prover functionality is to check if
two Discourse Representation Structures (DRSs) have the same meaning.
The ``tp_equals()`` method calls Prover9 to determine whether (the
FOL versions of) two DRSs are logically equivalent.

    >>> from nltk_contrib.drt import DRT
    >>> a = DRT.Parser().parse(r'drs([x],[(man x), (walks x)])')
    >>> b = DRT.Parser().parse(r'drs([x],[(walks x), (man x)])')
    >>> print a.tp_equals(b)
    True

Checking for equality of two DRSs is very useful when generating readings of a sentence.
For example, the ``drt_glue`` module generates two readings for the sentence 
*John sees Mary*:

    >>> from nltk_contrib.gluesemantics import drt_glue
    >>> readings = drt_glue.parse_to_meaning('John sees Mary')
    >>> 
    >>> for drs in readings: print drs.simplify()
    ...
    DRS([z1,x],[(= z1 John),(= x Mary),(sees z1 x)])
    DRS([z2,x],[(= z2 Mary),(= x John),(sees x z2)])

However, it is easy to tell that these two readings are logically the
same, and therefore one of them is superfluous.  We can use the theorem prover
to determine this equivalence, and then delete one of them.

    >>> readings[0].tp_equals(readings[1])
    True

--------------------------------
NLTK Interface to Model Builders
--------------------------------

The top-level to model builders is parallel to that for
theorem-provers. The method ``get_model_builder()`` takes an
``Expression`` and, optionally, the name of a model builder prover.
The default is ``'Mace'``, (or more precisely, ``'Mace4'``) which is
currently the only model builder supported.

Typically we use a model builder to show that some set of formulas has
a model, and is therefore consistent. One way of doing this is by
treating our candidate set of sentences as assumptions, and leaving
the goal unspecified. 
Thus, the following interaction shows how both ``{a, c1}`` and ``{a, c2}``
are consistent sets, since Mace succeeds in a building a
model for each of them, while ``{c1, c2}`` is inconsistent.

    >>> a3 = lp.parse('some x.((man x) and (walks x))')
    >>> c1 = lp.parse('(mortal socrates)')
    >>> c2 = lp.parse('(not (mortal socrates))')
    >>> print get_model_builder('', [a3, c1]).model_found()
    True
    >>> print get_model_builder('', [a3, c2]).model_found()
    True

We can also use the model builder as an adjunct to theorem prover.
Let's suppose we are trying to prove ``S |- g``, i.e. that ``g``
is logically entailed by assumptions ``S = {s1, s2, ..., sn}``.
We can this same input to Mace4, and the model builder will try to
find a counterexample, that is, to show that ``g`` does *not* follow
from ``S``. So, given this input, Mace4 will try to find a model for
the set ``S' = {s1, s2, ..., sn, (not g)}``. If ``g`` fails to follow
from ``S``, then Mace4 may well return with a counterexample faster
than Prover9 concludes that it cannot find the required proof.
Conversely, if ``g`` *is* provable from ``S``, Mace4 may take a long
time unsuccessfully trying to find a counter model, and will eventually give up.

In the following example, we see that the model builder does succeeed
in building a model of the assumptions together with the negation of
the goal. That is, it succeeds in finding a model
where there is a woman that every man loves; Adam is a man; Eve is a
woman; but Adam does not love Eve.

    >>> a4 = lp.parse('some y. ((woman y) and all x. ((man x) implies (love y x)))')
    >>> a5 = lp.parse('(man adam)')
    >>> a6 = lp.parse('(woman eve)')
    >>> g = lp.parse('(love eve adam)')
    >>> print get_model_builder(g, [a4, a5, a6]).model_found()
    True


-----
Mace4
-----

Mace4 Installation
~~~~~~~~~~~~~~~~~~

Mace4 is packaged with Prover9, and can be downloaded from the same
source, namely http://www.cs.unm.edu/~mccune/prover9/. It is installed
in the same manner as Prover9.

Using Mace4
~~~~~~~~~~~

Check whether Mace4 can find a model.

    >>> a = LogicParser().parse('((see john mary) and (not (mary = john)))')
    >>> mb = Mace('', assumptions=[a])
    >>> mb.model_found()
    True

Show the model in 'tabular' format.

    >>> mb.show_output(format='tabular')
    % number = 1
    % seconds = 0
    <BLANKLINE>
    % Interpretation of size 2
    <BLANKLINE>
     john : 0
    <BLANKLINE>
     mary : 1
    <BLANKLINE>
     see : 
           | 0 1
        ---+----
         0 | 0 1
         1 | 0 0
    <BLANKLINE>

Show the model in 'tabular' format.

    >>> mb.show_output(format='cooked')
    % number = 1
    % seconds = 0
    <BLANKLINE>
    % Interpretation of size 2
    <BLANKLINE>
    john = 0.
    <BLANKLINE>
    mary = 1.
    <BLANKLINE>
    - see(0,0).
      see(0,1).
    - see(1,0).
    - see(1,1).
    <BLANKLINE>

The method ``build_model()`` returns a ``Valuation``.

    >>> print mb.build_model()
    {'john': 'a',
     'mary': 'b',
     'see': {'a': {'a': False, 'b': True}, 'b': {'a': False, 'b': False}}}

We can return to our earlier example and inspect the model:

    >>> mb = Mace(g, assumptions=[a4, a5, a6])
    >>> m = mb.build_model()
    >>> mb.show_output(format='cooked')
    % number = 1
    % seconds = 0
    <BLANKLINE>
    % Interpretation of size 2
    <BLANKLINE>
    adam = 0.
    <BLANKLINE>
    eve = 0.
    <BLANKLINE>
    c1 = 1.
    <BLANKLINE>
      man(0).
    - man(1).
    <BLANKLINE>
      woman(0).
      woman(1).
    <BLANKLINE>
    - love(0,0).
    - love(0,1).
      love(1,0).
    - love(1,1).
    <BLANKLINE>

Here, we can see that ``adam`` and ``eve`` have been assigned the same
individual, namely ``0`` as value; ``0`` is both a man and a woman; a second
individual ``1`` is also a woman; and ``0`` loves ``1``. Thus, this is
an interpretation in which there is a woman that every man loves but
Adam doesn't love Eve.

------------------
Discourse Checking
------------------


    >>> dt = DiscourseTester(['a boxer walks', 'every boxer chases a girl'])

    >>> dt.sentences()
    s0: a boxer walks
    s1: every boxer chases a girl

    >>> dt.readings()
    <BLANKLINE>
    s0 readings:
    ------------------------------
    s0-r1: some x.((boxer2 x) and (walk x))
    s0-r0: some x.((boxer1 x) and (walk x))
    <BLANKLINE>
    s1 readings:
    ------------------------------
    s1-r0: all x.((boxer1 x) implies some z220.((girl z220) and (chase z220 x)))
    s1-r1: all x.((boxer2 x) implies some z239.((girl z239) and (chase z239 x)))

    >>> dt.readings(summarize=True)
    d0: ['s0-r0', 's1-r0']
    d1: ['s0-r0', 's1-r1']
    d2: ['s0-r1', 's1-r0']
    d3: ['s0-r1', 's1-r1']

    >>> dt.models('d1')
    --------------------------------------------------------------------------------
    Discourse Thread d1
    --------------------------------------------------------------------------------
    some x.((boxer1 x) and (walk x))
    all x.((boxer2 x) implies some z362.((girl z362) and (chase z362 x)))
    --------------------------------------------------------------------------------
    % number = 1
    % seconds = 0
    <BLANKLINE>
    % Interpretation of size 2
    <BLANKLINE>
    c1 = 0.
    <BLANKLINE>
    f1(0) = 0.
    f1(1) = 0.
    <BLANKLINE>
      boxer1(0).
    - boxer1(1).
    <BLANKLINE>
    - boxer2(0).
    - boxer2(1).
    <BLANKLINE>
    - girl(0).
    - girl(1).
    <BLANKLINE>
      walk(0).
    - walk(1).
    <BLANKLINE>
    - chase(0,0).
    - chase(0,1).
    - chase(1,0).
    - chase(1,1).
    <BLANKLINE>
    >>> dt.add_sentence('John is a boxer')

    >>> dt.sentences()
    s0: a boxer walks
    s1: every boxer chases a girl
    s2: John is a boxer

    >>> dt.readings()
    <BLANKLINE>
    s0 readings:
    ------------------------------
    s0-r1: some x.((boxer2 x) and (walk x))
    s0-r0: some x.((boxer1 x) and (walk x))
    <BLANKLINE>
    s1 readings:
    ------------------------------
    s1-r0: all x.((boxer1 x) implies some z613.((girl z613) and (chase z613 x)))
    s1-r1: all x.((boxer2 x) implies some z632.((girl z632) and (chase z632 x)))
    <BLANKLINE>
    s2 readings:
    ------------------------------
    s2-r1: (boxer2 john)
    s2-r0: (boxer1 john)


    >>> dt.readings(summarize=True)
    d0: ['s0-r0', 's1-r0', 's2-r0']
    d1: ['s0-r0', 's1-r0', 's2-r1']
    d2: ['s0-r0', 's1-r1', 's2-r0']
    d3: ['s0-r0', 's1-r1', 's2-r1']
    d4: ['s0-r1', 's1-r0', 's2-r0']
    d5: ['s0-r1', 's1-r0', 's2-r1']
    d6: ['s0-r1', 's1-r1', 's2-r0']
    d7: ['s0-r1', 's1-r1', 's2-r1']



==============
Theorem Prover
==============

---------------------------------
NLTK Interface to Theorem Provers
---------------------------------

The module ``nltk_contrib.theorem_prover`` can be used to access the 
theorem provers.  The module contains a method ``attempt_proof()`` that takes 
an ``Expression`` and, optionally, a name of a theorem prover.  The default is 
``'Prover9'`` , but the tableau prover may be used by specifying ``'tableau'``.


    >>> from nltk_contrib import inference
    >>> from nltk_contrib.drt import DRT
    >>> f = DRT.Parser().parse('drs([],[(drs([],[(man x)]) implies drs([],[(man x)]))])').toFol()
    >>> print f
    (implies (man x) (man x))
    >>> inference.Prover9(f).prove()
    True


-------
Prover9
-------
Prover9 Installation
~~~~~~~~~~~~~~~~~~~~

You can download Prover9 from http://www.cs.unm.edu/~mccune/prover9/.



Extract the source code into a suitable directory and follow the
instructions in the Prover9 ``README.make`` file to compile the executables.
Install these into an appropriate location; the
``prover9_search`` variable is currently configured to look in the
following locations::

    ['.', '/usr/local/bin/prover9', '/usr/local/bin/prover9/bin',
    '/usr/local/bin', '/usr/bin', '/usr/local/prover9',
    '/usr/local/share/prover9']

    
Using Prover9
~~~~~~~~~~~~~

The input to ``Prover9`` must be ``Expression``\ s of nltk.sem.logic.
    >>> from nltk.sem import LogicParser
    >>> g = LogicParser().parse('((man x) iff (not (not (man x))))')

A ``Prover9`` instance is initialized with a goal and, possibly, some
assumptions. The ``prove()`` method attempts to find a proof of the goal,
given the list of assumptions (in this case, none).

    >>> prover = inference.Prover9(g)
    >>> prover.prove()
    True

We can also call the ``prove()`` method directly:

    >>> g = LogicParser().parse('all x. ((man x) implies (man x))')
    >>> print inference.Prover9(g).prove()
    True
    
Given a ``Prover9`` instance ``prover``, the method
``prover.show_proof()`` will print out the extensive proof information
provided by Prover9, shown in abbreviated form here::

    ============================== Prover9 ===============================
    Prover9 (32) version Dec-2007, Dec 2007.
    Process 6317 was started by ewan on isalpha.local,
    Mon Jan 21 15:23:28 2008
    The command was "/usr/local/bin/prover9 -f /var/...

    ============================== end of head ===========================
    <BLANKLINE>
    ============================== INPUT =================================
    <BLANKLINE>
    % Reading from file /var/...
    <BLANKLINE>
    <BLANKLINE>
    formulas(goals).
    (all x (man(x) -> man(x))).
    end_of_list.

    ...
    ============================== end of search =========================
    <BLANKLINE>
    THEOREM PROVED
    <BLANKLINE>
    Exiting with 1 proof.
    <BLANKLINE>
    Process 6317 exit (max_proofs) Mon Jan 21 15:23:28 2008


As mentioned earlier, we can explicitly specify the assumptions for
the proof, as shown here.

    >>> g = LogicParser().parse('(mortal Socrates)')
    >>> a1 = LogicParser().parse('all x.((man x) implies (mortal x))')
    >>> prover = inference.Prover9(g, assumptions=[a1])
    >>> prover.assumptions()
    all x.((man x) implies (mortal x))

However, the assumptions are not sufficient to derive the goal:

    ['all x.((man x) implies (mortal x))']
    >>> print prover.prove()
    False

So let's add another assumption:

    >>> a2 = LogicParser().parse('(man Socrates)')    
    >>> prover.add_assumptions([a2])
    >>> prover.assumptions()
    all x.((man x) implies (mortal x))
    (man Socrates)
    >>> print prover.prove()
    True

We can also show the assumptions in ``Prover9`` format.

    >>> prover.assumptions(output_format='Prover9')
    all x (man(x) -> mortal(x))
    man(Socrates)

    >>> prover.assumptions(output_format='Spass')
    Traceback (most recent call last):
      . . .
    NameError: Unrecognized value for 'output_format': Spass

Assumptions can be retracted from the list of assumptions.

    >>> prover.retract_assumptions([a1])
    >>> prover.assumptions()
    (man Socrates)
    >>> prover.retract_assumptions([a1])

Statements can be load from a file and parsed. We can then add these
a statements as new assumptions.

    >>> g = LogicParser().parse('all x. ((boxer1 x) implies (not (boxer2 x)))')
    >>> prover = inference.Prover9(g)
    >>> new = prover.load('onto1.fol')
    >>> for a in new:
    ...     print a.infixify()
    all x.((boxer2 x) implies (dog x))
    all x.((boxer1 x) implies (person x))
    all x.(not ((dog x) and (person x)))
    all x.(not ((kitchen x) and (garden x)))
    all x.((kitchen x) implies (location x))
    all x.((garden x) implies (location x))
    >>> prover.add_assumptions(new)
    >>> print prover.prove()
    True


------------
DRS Equality
------------

One application of the theorem prover functionality is to check if
two Discourse Representation Structures (DRSs) have the same meaning.
The ``tp_equals()`` method calls Prover9 to determine whether (the
FOL versions of) two DRSs are logically equivalent.

    >>> from nltk_contrib.drt import DRT
    >>> a = DRT.Parser().parse(r'drs([x],[(man x), (walks x)])')
    >>> b = DRT.Parser().parse(r'drs([x],[(walks x), (man x)])')
    >>> print a.tp_equals(b)
    True

Checking for equality of two DRSs is very useful when generating readings of a sentence.
For example, the ``drt_glue`` module generates two readings for the sentence 
*John sees Mary*:

    >>> from nltk_contrib.gluesemantics import drt_glue
    >>> readings = drt_glue.parse_to_meaning('John sees Mary')
    >>> 
    >>> for drs in readings: print drs.simplify()
    ...
    DRS([z1,x],[(= z1 John),(= x Mary),(sees z1 x)])
    DRS([z2,x],[(= z2 Mary),(= x John),(sees x z2)])

However, it is easy to tell that these two readings are logically the
same, and therefore one of them is superfluous.  We can use the theorem prover
to determine this equivalence, and then delete one of them.

    >>> readings[0].tp_equals(readings[1])
    True


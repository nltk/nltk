===============================
 Unit tests for nltk.tree.Tree
===============================

    >>> from nltk.tree import *

    >>> print Tree(1, [2, 3, 4])
    (1 2 3 4)
    >>> print Tree('S', [Tree('NP', ['I']), 
    ...                 Tree('VP', [Tree('V', ['saw']),
    ...                             Tree('NP', ['him'])])])
    (S (NP I) (VP (V saw) (NP him)))

One exception to "any iterable": in order to avoid confusion,
strings are *not* accepted as children lists:

    >>> print Tree('NP', 'Bob')
    Traceback (most recent call last):
      ...
    TypeError: children should be a list, not a string

A single level can contain both leaves and subtrees:

    >>> print Tree(1, [2, Tree(3, [4]), 5])
    (1 2 (3 4) 5)

Some trees to run tests on:

    >>> dp1 = Tree('dp', [Tree('d', ['the']), Tree('np', ['dog'])])
    >>> dp2 = Tree('dp', [Tree('d', ['the']), Tree('np', ['cat'])])
    >>> vp = Tree('vp', [Tree('v', ['chased']), dp2])
    >>> tree = Tree('s', [dp1, vp])
    >>> print tree
    (s (dp (d the) (np dog)) (vp (v chased) (dp (d the) (np cat))))

The node value is stored using the `node` attribute:

    >>> dp1.node, dp2.node, vp.node, tree.node
    ('dp', 'dp', 'vp', 's')

This attribute can be modified directly:

    >>> dp1.node = 'np'
    >>> dp2.node = 'np'
    >>> print tree
    (s (np (d the) (np dog)) (vp (v chased) (np (d the) (np cat))))

Children can be accessed with indexing, just as with normal lists:

    >>> print tree[0]
    (np (d the) (np dog))
    >>> print tree[1][1]
    (np (d the) (np cat))

Children can be modified directly, as well:

    >>> tree[0], tree[1][1] = tree[1][1], tree[0]
    >>> print tree
    (s (np (d the) (np cat)) (vp (v chased) (np (d the) (np dog))))

The `Tree` class adds a new method of indexing, using tuples rather
than ints.  ``t[a,b,c]`` is equivalant to ``t[a][b][c]``.  The sequence
``(a,b,c)`` is called a "tree path".

    >>> print tree[1,1][0]
    (d the)

    >>> # Switch the cat & dog back the way they were.
    >>> tree[1,1], tree[0] = tree[0], tree[1,1]
    >>> print tree
    (s (np (d the) (np dog)) (vp (v chased) (np (d the) (np cat))))

    >>> path = (1,1,1,0)
    >>> print tree[path]
    cat

The length of a tree is the number of children it has.

    >>> len(tree), len(dp1), len(dp2), len(dp1[0])
    (2, 2, 2, 1)
    >>> len(Tree('x', []))
    0

The `leaves` method returns a list of a tree's leaves:

    >>> print tree.leaves()
    ['the', 'dog', 'chased', 'the', 'cat']

The `height` method returns the height of the tree.  A tree with no
children is considered to have a height of 1; a tree with only
children is considered to have a height of 2; and any other tree's
height is one plus the maximum of its children's heights:

    >>> print tree.height()
    5
    >>> print tree[1,1,1].height()
    2
    >>> print tree[0].height()
    3

The `treepositions` method returns a list of the tree positions of
subtrees and leaves in a tree.  By default, it gives the position of
every tree, subtree, and leaf, in prefix order:

    >>> print tree.treepositions()
    [(), (0,), (0, 0), (0, 0, 0), (0, 1), (0, 1, 0), (1,), (1, 0), (1, 0, 0), (1, 1), (1, 1, 0), (1, 1, 0, 0), (1, 1, 1), (1, 1, 1, 0)]

The order can also be specified explicitly.  Four orders are currently
supported:

    # Prefix order
    >>> print tree.treepositions('preorder')
    [(), (0,), (0, 0), (0, 0, 0), (0, 1), (0, 1, 0), (1,), (1, 0), (1, 0, 0), (1, 1), (1, 1, 0), (1, 1, 0, 0), (1, 1, 1), (1, 1, 1, 0)]

    # Postfix order
    >>> print tree.treepositions('postorder')
    [(0, 0, 0), (0, 0), (0, 1, 0), (0, 1), (0,), (1, 0, 0), (1, 0), (1, 1, 0, 0), (1, 1, 0), (1, 1, 1, 0), (1, 1, 1), (1, 1), (1,), ()]
    
    # Both prefix & postfix order (subtrees listed twice, leaves once)
    >>> print tree.treepositions('bothorder')
    [(), (0,), (0, 0), (0, 0, 0), (0, 0), (0, 1), (0, 1, 0), (0, 1), (0,), (1,), (1, 0), (1, 0, 0), (1, 0), (1, 1), (1, 1, 0), (1, 1, 0, 0), (1, 1, 0), (1, 1, 1), (1, 1, 1, 0), (1, 1, 1), (1, 1), (1,), ()]
    
    # Leaves only (in order)
    >>> print tree.treepositions('leaves')
    [(0, 0, 0), (0, 1, 0), (1, 0, 0), (1, 1, 0, 0), (1, 1, 1, 0)]

`treepositions` can be useful for modifying a tree.  For example, we
could upper-case all leaves with:

    >>> for pos in tree.treepositions('leaves'):
    ...     tree[pos] = tree[pos].upper()
    >>> print tree
    (s (np (d THE) (np DOG)) (vp (v CHASED) (np (d THE) (np CAT))))

In addition to `str` and `repr`, several methods exist to convert a
tree object to one of several standard tree encodings:

    >>> print tree.pprint_latex_qtree()
    \Tree [.s
            [.np [.d THE ] [.np DOG ] ]
            [.vp [.v CHASED ] [.np [.d THE ] [.np CAT ] ] ] ]

Trees can be parsed from treebank strings with the static
`Tree.parse` method:

    >>> tree2 = bracket_parse('(S (NP I) (VP (V enjoyed) (NP my cookie)))')
    >>> print tree2
    (S (NP I) (VP (V enjoyed) (NP my cookie)))

Trees can be compared for equality:

    >>> tree == bracket_parse(str(tree))
    True
    >>> tree2 == bracket_parse(str(tree2))
    True
    >>> tree == tree2
    False
    >>> tree == bracket_parse(str(tree2))
    False
    >>> tree2 == bracket_parse(str(tree))
    False

    >>> tree != bracket_parse(str(tree))
    False
    >>> tree2 != bracket_parse(str(tree2))
    False
    >>> tree != tree2
    True
    >>> tree != bracket_parse(str(tree2))
    True
    >>> tree2 != bracket_parse(str(tree))
    True
    
    >>> tree < tree2 or tree > tree2
    True

Tree Parsing
============

The class method `Tree.parse()` can be used to parse trees:

    >>> tree = Tree.parse('(S (NP I) (VP (V enjoyed) (NP my cookie)))')
    >>> print tree
    (S (NP I) (VP (V enjoyed) (NP my cookie)))

When called on a subclass of `Tree`, it will create trees of that
type:

    >>> tree = ImmutableTree.parse('(VP (V enjoyed) (NP my cookie))')
    >>> print tree
    (VP (V enjoyed) (NP my cookie))
    >>> print type(tree)
    <class 'nltk.tree.ImmutableTree'>

The ``brackets`` parameter can be used to specify two characters that
should be used as brackets:

    >>> print Tree.parse('[S [NP I] [VP [V enjoyed] [NP my cookie]]]',
    ...                  brackets='[]')
    (S (NP I) (VP (V enjoyed) (NP my cookie)))
    >>> print Tree.parse('<S <NP I> <VP <V enjoyed> <NP my cookie>>>',
    ...                  brackets='<>')
    (S (NP I) (VP (V enjoyed) (NP my cookie)))

If ``brackets`` is not a string, or is not exactly two characters,
then `Tree.parse` raises an exception: 

    >>> Tree.parse('<VP <V enjoyed> <NP my cookie>>', brackets='')
    Traceback (most recent call last):
      . . .
    TypeError: brackets must be a length-2 string
    >>> Tree.parse('<VP <V enjoyed> <NP my cookie>>', brackets='<<>>')
    Traceback (most recent call last):
      . . .
    TypeError: brackets must be a length-2 string
    >>> Tree.parse('<VP <V enjoyed> <NP my cookie>>', brackets=12)
    Traceback (most recent call last):
      . . .
    TypeError: object of type 'int' has no len()
    >>> Tree.parse('<<NP my cookie>>', brackets=('<<','>>'))
    Traceback (most recent call last):
      . . .
    TypeError: brackets must be a length-2 string

(We may add support for multi-character brackets in the future, in
which case the ``brackets=('<<','>>')`` example would start working.)

Whitespace brackets are not permitted:

    >>> Tree.parse('(NP my cookie\n', brackets='(\n')
    Traceback (most recent call last):
      . . .
    TypeError: whitespace brackets not allowed
    
If an invalid tree is given to Tree.parse, then it raises a
ValueError, with a description of the problem:

    >>> Tree.parse('(NP my cookie) (NP my milk)')
    Traceback (most recent call last):
      . . .
    ValueError: Tree.parse(): expected 'end-of-string' but got '(NP'
                at index 15.
                    "...y cookie) (NP my mil..."
                                  ^
    >>> Tree.parse(')NP my cookie(')
    Traceback (most recent call last):
      . . .
    ValueError: Tree.parse(): expected '(' but got ')'
                at index 0.
                    ")NP my coo..."
                     ^
    >>> Tree.parse('(NP my cookie))')
    Traceback (most recent call last):
      . . .
    ValueError: Tree.parse(): expected 'end-of-string' but got ')'
                at index 14.
                    "...my cookie))"
                                  ^
    >>> Tree.parse('my cookie)')
    Traceback (most recent call last):
      . . .
    ValueError: Tree.parse(): expected '(' but got 'my'
                at index 0.
                    "my cookie)"
                     ^
    >>> Tree.parse('(NP my cookie')
    Traceback (most recent call last):
      . . .
    ValueError: Tree.parse(): expected ')' but got 'end-of-string'
                at index 13.
                    "... my cookie"
                                  ^
    >>> Tree.parse('')
    Traceback (most recent call last):
      . . .
    ValueError: Tree.parse(): expected '(' but got 'end-of-string'
                at index 0.
                    ""
                     ^
    
Trees with no children are supported:

    >>> print Tree.parse('(S)')
    (S )
    >>> print Tree.parse('(X (Y) (Z))')
    (X (Y ) (Z ))

Trees with an empty node and no children are supported:

    >>> print Tree.parse('()')
    ( )
    >>> print Tree.parse('(X () ())')
    (X ( ) ( ))

Trees with an empty node and children are supported, but only if the
first child is not a leaf (otherwise, it will be treated as the node
value).

    >>> print Tree.parse('((A) (B) (C))')
    ( (A ) (B ) (C ))
    >>> print Tree.parse('((A) leaf)')
    ( (A ) leaf)
    >>> print Tree.parse('(((())))')
    ( ( ( ( ))))

The optional arguments `parse_node` and `parse_leaf` may be used to
transform the string values of nodes or leaves.

    >>> print Tree.parse('(A b (C d e) (F (G h i)))',
    ...                  parse_node=lambda s: '<%s>' % s,
    ...                  parse_leaf=lambda s: '"%s"' % s)
    (<A> "b" (<C> "d" "e") (<F> (<G> "h" "i")))

These transformation functions are typically used when the node or
leaf values should be parsed to a non-string value (such as a feature
structure).  If node values and leaf values need to be able to include
whitespace, then you must also use the optional `node_pattern` and
`leaf_pattern` arguments.

    >>> from nltk.featstruct import FeatStruct
    >>> tree = Tree.parse('([cat=NP] [lex=the] [lex=dog])',
    ...                   parse_node=FeatStruct, parse_leaf=FeatStruct)
    >>> tree.node = tree.node.unify(FeatStruct('[num=singular]'))
    >>> print tree
    ([cat='NP', num='singular'] [lex='the'] [lex='dog'])

The optional argument ``remove_empty_top_bracketing`` can be used to
remove any top-level empty bracketing that occurs.

    >>> print Tree.parse('((S (NP I) (VP (V enjoyed) (NP my cookie))))',
    ...                  remove_empty_top_bracketing=True)
    (S (NP I) (VP (V enjoyed) (NP my cookie)))

It will not remove a top-level empty bracketing with multiple children:

    >>> print Tree.parse('((A a) (B b))')
    ( (A a) (B b))

Squashed Bugs
=============
This used to cause an infinite loop (fixed in svn 6269):

    >>> tree < None
    False

This used to discard the ``(B b)`` subtree (fixed in svn 6270):

    >>> print bracket_parse('((A a) (B b))')
    ( (A a) (B b))


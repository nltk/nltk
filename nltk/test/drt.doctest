================================
 Discourse Representation Theory
================================

.. include:: ../../doc/definitions.rst

A DRS can be created with ``DRS()``. This takes two arguments: a list of
discourse referents and list of conditions. 

    >>> from nltk.sem.drt import *
    
    >>> dp = DrtParser()
    
    >>> man_x = dp.parse('man(x)')
    >>> walk_x = dp.parse('walk(x)')
    >>> x = dp.parse('x')
    >>> print DRS([x], [man_x, walk_x])
    ([x],[man(x), walk(x)])

The ``parse()`` method can also be applied directly to DRS
expressions, which allows them to be specified more
easily.

    >>> drs1 = dp.parse('([x],[man(x),walk(x)])')
    >>> print drs1
    ([x],[man(x), walk(x)])

DRSs can be *merged* using the ``+`` operator.

    >>> drs2 = dp.parse('([y],[woman(y),stop(y)])')
    >>> drs3 = drs1 + drs2
    >>> print drs3.simplify()
    ([x,y],[man(x), walk(x), woman(y), stop(y)])

We can embed DRSs as components of an ``implies`` condition.

    >>> s = '([], [(%s -> %s)])' % (drs1, drs2)
    >>> print dp.parse(s)
    ([],[(([x],[man(x), walk(x)]) -> ([y],[woman(y), stop(y)]))])


Parser
    
    >>> print dp.parse(r'([x,y],[sees(x,y)])')
    ([x,y],[sees(x,y)])
    >>> print dp.parse(r'([x],[man(x), walks(x)])')
    ([x],[man(x), walks(x)])
    >>> print dp.parse(r'\x.([],[man(x), walks(x)])')
    \x.([],[man(x), walks(x)])
    >>> print dp.parse(r'\x.\y.([],[sees(x,y)])')
    \x y.([],[sees(x,y)])

    >>> print dp.parse(r'([x,y],[(x = y)])')
    ([x,y],[(x = y)])
    >>> print dp.parse(r'([x,y],[(x != y)])')
    ([x,y],[-(x = y)])

    >>> print dp.parse(r'\x.([],[walks(x)])(john)')
    (\x.([],[walks(x)]))(john)
    >>> print dp.parse(r'\R.\x.([],[big(x,R)])(\y.([],[mouse(y)]))')
    (\R x.([],[big(x,R)]))(\y.([],[mouse(y)]))

    >>> print dp.parse(r'(([x],[walks(x)]) + ([y],[runs(y)]))')
    (([x],[walks(x)]) + ([y],[runs(y)]))
    >>> print dp.parse(r'(([x,y],[walks(x), jumps(y)]) + (([z],[twos(z)]) + ([w],[runs(w)])))')
    (([x,y],[walks(x), jumps(y)]) + (([z],[twos(z)]) + ([w],[runs(w)])))
    >>> print dp.parse(r'((([],[walks(x)]) + ([],[twos(x)])) + ([],[runs(x)]))')
    ((([],[walks(x)]) + ([],[twos(x)])) + ([],[runs(x)]))
    >>> print dp.parse(r'((([],[walks(x)]) + ([],[runs(x)])) + (([],[threes(x)]) + ([],[fours(x)])))')
    ((([],[walks(x)]) + ([],[runs(x)])) + (([],[threes(x)]) + ([],[fours(x)])))

    >>> print dp.parse(r'(([],[walks(x)]) -> ([],[runs(x)]))')
    (([],[walks(x)]) -> ([],[runs(x)]))

    >>> print dp.parse(r'([x],[PRO(x), sees(John,x)])')
    ([x],[PRO(x), sees(John,x)])
    >>> print dp.parse(r'([x],[man(x), -([],[walks(x)])])')
    ([x],[man(x), -([],[walks(x)])])
    >>> print dp.parse(r'([],[(([x],[man(x)]) -> ([],[walks(x)]))])')
    ([],[(([x],[man(x)]) -> ([],[walks(x)]))])
    
    >>> print dp.parse(r'DRS([x],[walk(x)])')
    ([x],[walk(x)])
    >>> print dp.parse(r'DRS([x][walk(x)])')
    ([x],[walk(x)])
    >>> print dp.parse(r'([x][walk(x)])')
    ([x],[walk(x)])
    
Simplify

    >>> print dp.parse(r'\x.([],[man(x), walks(x)])(john)').simplify()
    ([],[man(john), walks(john)])
    >>> print dp.parse(r'\x.\y.([z],[dog(z),sees(x,y)])(john)(mary)').simplify()
    ([z],[dog(z), sees(john,mary)])
    >>> print dp.parse(r'\R x.([],[big(x,R)])(\y.([],[mouse(y)]))').simplify()
    \x.([],[big(x,\y.([],[mouse(y)]))])
    
    >>> print dp.parse(r'(([x],[walks(x)]) + ([y],[runs(y)]))').simplify()
    ([x,y],[walks(x), runs(y)])
    >>> print dp.parse(r'(([x,y],[walks(x), jumps(y)]) + (([z],[twos(z)]) + ([w],[runs(w)])))').simplify()
    ([x,y,z,w],[walks(x), jumps(y), twos(z), runs(w)])
    >>> print dp.parse(r'((([],[walks(x)]) + ([],[runs(x)]) + ([],[threes(x)]) + ([],[fours(x)])))').simplify()
    ([],[walks(x), runs(x), threes(x), fours(x)])
    >>> d1 = dp.parse(r'([x],[man(x)])+([x],[walks(x)])').simplify()
    >>> d2 = dp.parse(r'([x,z1],[man(x), walks(z1)])')
    >>> d1 == d2
    True
        
    >>> d1 = dp.parse(r'\Q.(([x],[john(x),walks(x)]) + Q)(([x],[PRO(x),leaves(x)]))').simplify()
    >>> d2 = dp.parse(r'([x,z1],[john(x), walks(x), PRO(z1), leaves(z1)])')
    >>> d1 == d2
    True
    
toFol()

    >>> print dp.parse(r'([x,y],[sees(x,y)])').toFol()
    exists x y.sees(x,y)
    >>> print dp.parse(r'([x],[man(x), walks(x)])').toFol()
    exists x.(man(x) & walks(x))
    >>> print dp.parse(r'\x.([],[man(x), walks(x)])').toFol()
    \x.(man(x) & walks(x))
    >>> print dp.parse(r'\x y.([],[sees(x,y)])').toFol()
    \x y.sees(x,y)

    >>> print dp.parse(r'\x.([],[walks(x)])(john)').toFol()
    \x.walks(x)(john)
    >>> print dp.parse(r'\R x.([],[big(x,R)])(\y.([],[mouse(y)]))').toFol()
    (\R x.big(x,R))(\y.mouse(y))

    >>> print dp.parse(r'(([x],[walks(x)]) + ([y],[runs(y)]))').toFol()
    (exists x.walks(x) & exists y.runs(y))

    >>> print dp.parse(r'(([],[walks(x)]) -> ([],[runs(x)]))').toFol()
    (walks(x) -> runs(x))

    >>> print dp.parse(r'([x],[PRO(x), sees(John,x)])').toFol()
    exists x.(PRO(x) & sees(John,x))
    >>> print dp.parse(r'([x],[man(x), -([],[walks(x)])])').toFol()
    exists x.(man(x) & -walks(x))
    >>> print dp.parse(r'([],[(([x],[man(x)]) -> ([],[walks(x)]))])').toFol()
    all x.(man(x) -> walks(x))

    >>> print dp.parse(r'([x],[man(x) | walks(x)])').toFol()
    exists x.(man(x) | walks(x))
    >>> print dp.parse(r'([x],[man(x) <-> walks(x)])').toFol()
    exists x.(man(x) <-> walks(x))
    >>> print dp.parse(r'P(x) + ([x],[walks(x)])').toFol()
    (P(x) & exists x.walks(x))

resolve_anaphora()

    >>> print dp.parse(r'([x,y,z],[dog(x), cat(y), walks(z), PRO(z)])').resolve_anaphora()
    ([x,y,z],[dog(x), cat(y), walks(z), (z = [x,y])])
    >>> print dp.parse(r'([],[(([x],[dog(x)]) -> ([y],[walks(y), PRO(y)]))])').resolve_anaphora()
    ([],[(([x],[dog(x)]) -> ([y],[walks(y), (y = x)]))])
    >>> print dp.parse(r'(([x,y],[]) + ([],[PRO(x)]))').resolve_anaphora().simplify()
    ([x,y],[(x = y)])
    >>> print dp.parse(r'([x],[walks(x), PRO(x)])').resolve_anaphora()
    ([x],[walks(x)])
    
    
replace():
    >>> a = dp.parse(r'a')
    >>> w = dp.parse(r'w')
    >>> x = dp.parse(r'x')
    >>> y = dp.parse(r'y')
    >>> z = dp.parse(r'z')


replace bound
    >>> print dp.parse(r'([x],[give(x,y,z)])').replace(x.variable, a, False)
    ([x],[give(x,y,z)])
    >>> print dp.parse(r'([x],[give(x,y,z)])').replace(x.variable, a, True)
    ([a],[give(a,y,z)])

replace unbound
    >>> print dp.parse(r'([x],[give(x,y,z)])').replace(y.variable, a, False)
    ([x],[give(x,a,z)])
    >>> print dp.parse(r'([x],[give(x,y,z)])').replace(y.variable, a, True)
    ([x],[give(x,a,z)])

replace unbound with bound
    >>> d1 = dp.parse(r'([x],[give(x,y,z)])').replace(y.variable, x, False)
    >>> d2 = dp.parse('([z1],[give(z1,x,z)])')
    >>> d1 == d2
    True
    >>> d1 = dp.parse(r'([x],[give(x,y,z)])').replace(y.variable, x, True)
    >>> d2 = dp.parse('([z1],[give(z1,x,z)])')
    >>> d1 == d2
    True

replace unbound with unbound
    >>> print dp.parse(r'([x],[give(x,y,z)])').replace(y.variable, z, False)
    ([x],[give(x,z,z)])
    >>> print dp.parse(r'([x],[give(x,y,z)])').replace(y.variable, z, True)
    ([x],[give(x,z,z)])
    

replace unbound
    >>> print dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,z)])').replace(z.variable, a, False)
    (([x],[P(x,y,a)]) + ([y],[Q(x,y,a)]))
    >>> print dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,z)])').replace(z.variable, a, True)
    (([x],[P(x,y,a)]) + ([y],[Q(x,y,a)]))

replace bound
    >>> print dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,z)])').replace(x.variable, a, False)
    (([x],[P(x,y,z)]) + ([y],[Q(x,y,z)]))
    >>> print dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,z)])').replace(x.variable, a, True)
    (([a],[P(a,y,z)]) + ([y],[Q(a,y,z)]))

replace unbound with unbound
    >>> print dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,z)])').replace(z.variable, a, False)
    (([x],[P(x,y,a)]) + ([y],[Q(x,y,a)]))
    >>> print dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,z)])').replace(z.variable, a, True)
    (([x],[P(x,y,a)]) + ([y],[Q(x,y,a)]))

replace unbound with bound on same side
    >>> a = dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,w)])').replace(z.variable, x, False)
    >>> b = dp.parse(r'(([z1],[P(z1,y,x)]) + ([y],[Q(z1,y,w)]))')
    >>> a == b
    True
    >>> a = dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,w)])').replace(z.variable, x, True)
    >>> b = dp.parse(r'(([z1],[P(z1,y,x)]) + ([y],[Q(z1,y,w)]))')
    >>> a == b
    True

replace unbound with bound on other side
    >>> a = dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,w)])').replace(w.variable, x, False)
    >>> b = dp.parse(r'(([z1],[P(z1,y,z)]) + ([y],[Q(z1,y,x)]))')
    >>> a == b
    True
    >>> a = dp.parse(r'([x],[P(x,y,z)])+([y],[Q(x,y,w)])').replace(w.variable, x, True)
    >>> b = dp.parse(r'(([z1],[P(z1,y,z)]) + ([y],[Q(z1,y,x)]))')
    >>> a == b
    True

replace unbound with double bound
    >>> a = dp.parse(r'([x],[P(x,y,z)])+([x],[Q(x,y,w)])').replace(z.variable, x, False)
    >>> b = dp.parse(r'(([z1],[P(z1,y,x)]) + ([z1],[Q(z1,y,w)]))')
    >>> a == b
    True
    >>> a = dp.parse(r'([x],[P(x,y,z)])+([x],[Q(x,y,w)])').replace(z.variable, x, True)
    >>> b = dp.parse(r'(([z1],[P(z1,y,x)]) + ([z1],[Q(z1,y,w)]))')
    >>> a == b
    True


Parse to semantics
------------------
	>>> logic._counter._value = 0

A logic parser can be passed as a parameter to load_earley
	>>> from nltk.parse import load_earley
	>>> parser = load_earley('grammars/drt.fcfg', trace=0, logic_parser=DrtParser())
	>>> trees = parser.nbest_parse('a dog barks'.split())
	>>> print trees[0].node['sem'].simplify()
	([x],[dog(x), bark(x)])

Alternatively, a FeatStructParser can be passed with the logic_parser set on it
	>>> from nltk.featstruct import FeatStructParser
	>>> from nltk.cfg import FeatStructNonterminal
	>>> parser = load_earley('grammars/drt.fcfg', trace=0, fstruct_parser=FeatStructParser(fdict_class=FeatStructNonterminal, logic_parser=DrtParser()))
	>>> trees = parser.nbest_parse('every girl chases a dog'.split())
	>>> print trees[0].node['sem'].simplify()
	([],[(([x],[girl(x)]) -> ([z2],[dog(z2), chase(x,z2)]))])
	
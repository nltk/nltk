--------------------------------------------------------------------------------
Unit tests for the Chunk classes
--------------------------------------------------------------------------------

    >>> from nltk.chunk import *
    >>> from nltk import Tree

    >>> tagged_text = "[ The/DT cat/NN ] sat/VBD on/IN [ the/DT mat/NN ] [ the/DT dog/NN ] chewed/VBD ./."
    >>> gold_chunked_text = tagstr2tree(tagged_text)
    >>> unchunked_text = gold_chunked_text.flatten()

Chunking uses a special regexp syntax for rules that delimit the chunks. These
rules must be converted to 'regular' regular expressions before a sentence can
be chunked.

    >>> tag_pattern = "<DT>?<JJ>*<NN.*>"
    >>> regexp_pattern = tag_pattern2re_pattern(tag_pattern)
    >>> regexp_pattern
    '(<(DT)>)?(<(JJ)>)*(<(NN[^\\{\\}<>]*)>)'

Construct some new chunking rules.

    >>> chunk_rule = ChunkRule("<.*>+", "Chunk everything")
    >>> chink_rule = ChinkRule("<VBD|IN|\.>", "Chink on verbs/prepositions")
    >>> split_rule = SplitRule("<DT><NN>", "<DT><NN>",
    ...                        "Split successive determiner/noun pairs")


Create and score a series of chunk parsers, successively more complex.

    >>> chunk_parser = RegexpChunk([chunk_rule], chunk_node='NP')
    >>> chunked_text = chunk_parser.parse(unchunked_text)
    >>> print chunked_text
    (S
      (NP
        ('The', 'DT')
        ('cat', 'NN')
        ('sat', 'VBD')
        ('on', 'IN')
        ('the', 'DT')
        ('mat', 'NN')
        ('the', 'DT')
        ('dog', 'NN')
        ('chewed', 'VBD')
        ('.', '.')))

    >>> chunkscore = ChunkScore()
    >>> chunkscore.score(gold_chunked_text, chunked_text)
    >>> chunkscore.precision()
    0.0

    >>> chunkscore.recall()
    0.0

    >>> chunkscore.f_measure()
    0

    >>> chunkscore.missed()
    [(('the', 'DT'), ('mat', 'NN')), (('the', 'DT'), ('dog', 'NN')), (('The', 'DT'), ('cat', 'NN'))]

    >>> chunkscore.incorrect()
    [(('The', 'DT'), ('cat', 'NN'), ('sat', 'VBD'), ('on', 'IN'), ('the', 'DT'), ('mat', 'NN'), ('the', 'DT'), ('dog', 'NN'), ('chewed', 'VBD'), ('.', '.'))]

    >>> chunk_parser = RegexpChunk([chunk_rule, chink_rule], chunk_node='NP')
    >>> chunked_text = chunk_parser.parse(unchunked_text)
    >>> print chunked_text
    (S
      (NP The/DT cat/NN)
      ('sat', 'VBD')
      ('on', 'IN')
      (NP the/DT mat/NN the/DT dog/NN)
      ('chewed', 'VBD')
      ('.', '.'))

    >>> chunkscore = ChunkScore()
    >>> chunkscore.score(gold_chunked_text, chunked_text)
    >>> chunkscore.precision()
    0.5

    >>> chunkscore.recall()
    0.33333333333333331

    >>> chunkscore.f_measure()
    0.40000000000000002

    >>> chunkscore.missed()
    [(('the', 'DT'), ('mat', 'NN')), (('the', 'DT'), ('dog', 'NN'))]

    >>> chunkscore.incorrect()
    [(('the', 'DT'), ('mat', 'NN'), ('the', 'DT'), ('dog', 'NN'))]

    >>> chunk_parser = RegexpChunk([chunk_rule, chink_rule, split_rule],
    ...                            chunk_node='NP')
    >>> chunked_text = chunk_parser.parse(unchunked_text)
    >>> print chunked_text
    (S
      (NP The/DT cat/NN)
      ('sat', 'VBD')
      ('on', 'IN')
      (NP the/DT mat/NN)
      (NP the/DT dog/NN)
      ('chewed', 'VBD')
      ('.', '.'))

    >>> chunkscore = ChunkScore()
    >>> chunkscore.score(gold_chunked_text, chunked_text)
    >>> chunkscore.precision()
    1.0

    >>> chunkscore.recall()
    1.0

    >>> chunkscore.f_measure()
    1.0

    >>> chunkscore.missed()
    []

    >>> chunkscore.incorrect()
    []


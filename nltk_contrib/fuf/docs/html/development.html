<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">
<div class="section">
<h1><a id="nltk-fuf-development" name="nltk-fuf-development"><cite>nltk.fuf</cite> Development</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Last Update:</th><td class="field-body">August 5th, 2008</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Petro Verkhogliad &lt;<a class="reference" href="mailto:vpetro&#64;gmail.com">vpetro&#64;gmail.com</a>&gt;</td>
</tr>
</tbody>
</table>
<p>This document details the current state of development of the <tt class="docutils literal"><span class="pre">nltk.fuf</span></tt> module
found in the <tt class="docutils literal"><span class="pre">nltk/nltk_contrib/fuf</span></tt> directory. In short, this code currently capable
of processing simple grammars (<tt class="docutils literal"><span class="pre">tests/gr0.fuf</span></tt> as grammar and <tt class="docutils literal"><span class="pre">tests/ir0.fuf</span></tt> as input or
<tt class="docutils literal"><span class="pre">tests/gr1.fuf</span></tt> with <tt class="docutils literal"><span class="pre">tests/ir1.fuf</span></tt>).</p>
</div>
<div class="section">
<h1><a id="overall-structure" name="overall-structure">Overall Structure</a></h1>
<ul class="simple">
<li><strong>fufconvert.py</strong> - converts a FUF grammar s-expression into an <tt class="docutils literal"><span class="pre">nltk.FeatStruct</span></tt>.
From here on, all of the work is done on feature structure found in <tt class="docutils literal"><span class="pre">nltk.featstruct</span></tt> module.</li>
<li><strong>fuf.py</strong> - uses the input feature structure and the grammar feature stucture and unifies them
according to the FUF unification guidlines (more on this later).</li>
<li><strong>linearizer.py</strong> - uses the results of the unification to produce the final text output
with the help of the <strong>morphology.py</strong></li>
</ul>
<div class="section">
<h2><a id="fufconvert-py-or-parsing-the-input" name="fufconvert-py-or-parsing-the-input">fufconvert.py or Parsing the input</a></h2>
<p>The <tt class="docutils literal"><span class="pre">fufconvert.py</span></tt> module is responsible for converting a given s-expression into a feature
structure. There are two main entry points for <tt class="docutils literal"><span class="pre">fufconvert.py</span></tt>.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">fufconvert.fuf_to_featstruct</span></tt> function.
This function a single s-expression into an NLTK feature structure.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import fufconvert
&gt;&gt;&gt; # read a line from the text file
&gt;&gt;&gt; line = open('tests/gr0.fuf').readlines()[0]
&gt;&gt;&gt; print line
&gt;&gt;&gt; # convert the line to feature structure
&gt;&gt;&gt; fstruct = fufconvert.fuf_to_featstruct(line)
&gt;&gt;&gt; print fstruct
</pre>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">fufconvert.fuf_file_to_featstruct</span></tt> function.
This function converts a grammar file that contains the grammar s-expression as well as
feature type declarations.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import fufconvert
&gt;&gt;&gt; type_table, grammar = fufconvert.fuf_file_to_featstruct('tests/typed_gr4.fuf')
</pre>
</blockquote>
<p>If there are not type definitions in the file then the <tt class="docutils literal"><span class="pre">type_table</span></tt> varible will contain
an empty dictionary.</p>
</li>
</ul>
<p>Both of the functions rely on <tt class="docutils literal"><span class="pre">sexp.py</span></tt> to parse and convert the file. The <tt class="docutils literal"><span class="pre">sexp.py</span></tt> module
uses a stack based state machine defined in <tt class="docutils literal"><span class="pre">statemachine.py</span></tt> file. The state machine does
bracket matching and will throw a <tt class="docutils literal"><span class="pre">ValueError</span></tt> if the brackets are mismatched.</p>
<p>At the same time, FUF defined some special keys and values that must be handled diffferently from
the usual key, value grammar pairs. They are:</p>
<ul>
<li><p class="first"><cite>alt</cite></p>
<p>This key defines alternations. There is no direct way to represent alternations within
the NLTK feature structures. <tt class="docutils literal"><span class="pre">nltk.fuf</span></tt> uses the following scheme:
- if the <cite>alt</cite> does not have a specific name it is represented like this:</p>
<blockquote>
<pre class="literal-block">
[           [     [ cat     = 's'                        ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ goal    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [ 1 = [ pattern = (prot, verb, goal)         ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ prot    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ verb    = [ cat    = 'vp'          ] ]            ] ]
[           [     [           [ number = {prot number} ] ]            ] ]
[           [                                                         ] ]
[           [     [       [ 1 = [ pattern = (n)   ]               ] ] ] ]
[           [     [       [     [ proper  = 'yes' ]               ] ] ] ]
[           [     [       [                                       ] ] ] ]
[           [     [ alt = [     [ det     = [ cat = 'article' ] ] ] ] ] ]
[           [     [       [     [           [ lex = 'the'     ] ] ] ] ] ]
[           [     [       [ 2 = [                               ] ] ] ] ]
[ alt     = [ 2 = [       [     [ pattern = (det, n)            ] ] ] ] ]
[           [     [       [     [ proper  = 'no'                ] ] ] ] ]
[           [     [                                                 ] ] ]
[           [     [ cat = 'np'                                      ] ] ]
[           [     [                                                 ] ] ]
[           [     [ n   = [ cat    = 'noun'     ]                   ] ] ]
[           [     [       [ number = {^^number} ]                   ] ] ]
[           [                                                         ] ]
[           [     [ cat     = 'vp'             ]                      ] ]
[           [ 3 = [ pattern = (v)              ]                      ] ]
[           [     [                            ]                      ] ]
[           [     [ v       = [ cat = 'verb' ] ]                      ] ]
[           [                                                         ] ]
[           [ 4 = [ cat = 'noun' ]                                    ] ]
[           [                                                         ] ]
[           [ 5 = [ cat = 'verb' ]                                    ] ]
[           [                                                         ] ]
[           [ 6 = [ cat = 'article' ]                                 ] ]
</pre>
<p>Note that there are two <cite>alt</cite> features in this grammar.</p>
</blockquote>
<ul>
<li><p class="first">if the <cite>alt</cite> does have a specific name it is represented like this:</p>
<pre class="literal-block">
[           [     [ cat     = 's'                        ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ goal    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [ 1 = [ pattern = (prot, verb, goal)         ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ prot    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ verb    = [ cat    = 'vp'          ] ]            ] ]
[           [     [           [ number = {prot number} ] ]            ] ]
[           [                                                         ] ]
[           [     [       [ 1 = [ pattern = (n)   ]               ] ] ] ]
[           [     [       [     [ proper  = 'yes' ]               ] ] ] ]
[           [     [       [                                       ] ] ] ]
[           [     [ alt = [     [ det     = [ cat = 'article' ] ] ] ] ] ]
[           [     [       [     [           [ lex = 'the'     ] ] ] ] ] ]
[           [     [       [ 2 = [                               ] ] ] ] ]
[ alt_top = [ 2 = [       [     [ pattern = (det, n)            ] ] ] ] ]
[           [     [       [     [ proper  = 'no'                ] ] ] ] ]
[           [     [                                                 ] ] ]
[           [     [ cat = 'np'                                      ] ] ]
[           [     [                                                 ] ] ]
[           [     [ n   = [ cat    = 'noun'     ]                   ] ] ]
[           [     [       [ number = {^^number} ]                   ] ] ]
[           [                                                         ] ]
[           [     [ cat     = 'vp'             ]                      ] ]
[           [ 3 = [ pattern = (v)              ]                      ] ]
[           [     [                            ]                      ] ]
[           [     [ v       = [ cat = 'verb' ] ]                      ] ]
[           [                                                         ] ]
[           [ 4 = [ cat = 'noun' ]                                    ] ]
[           [                                                         ] ]
[           [ 5 = [ cat = 'verb' ]                                    ] ]
[           [                                                         ] ]
[           [ 6 = [ cat = 'article' ]                                 ] ]
</pre>
<p>The difference is the <tt class="docutils literal"><span class="pre">_name</span></tt> in the <cite>alt</cite> string.</p>
</li>
</ul>
</li>
<li><p class="first">the next key is the <cite>opt</cite> key. It is very similar to <cite>alt</cite> in that it may have a name
and it also specifies a list of alternations (the unification for <cite>opt</cite> works slightly differently
, but more on this in the unification section). Since <cite>opt</cite> and <cite>alt</cite> are very similar <tt class="docutils literal"><span class="pre">nltk.fuf</span></tt>
uses the same <cite>alt</cite> syntax for the <cite>opt</cite> key. For example:</p>
<pre class="literal-block">
[       [ 1 = [ punctuation = [ after = '.' ] ] ] ]
[ alt = [                                       ] ]
[       [ 2 = []                                ] ]
</pre>
<p>If the <cite>opt</cite> is named then it is represented like this:</p>
<pre class="literal-block">
[                [ 1 = [ punctuation = [ after = '.' ] ] ] ]
[ alt_somename = [                                       ] ]
[                [ 2 = []                                ] ]
</pre>
</li>
</ul>
<p>The special parsing code for <cite>opt</cite> and <cite>alt</cite> is located in <tt class="docutils literal"><span class="pre">nltk.fuf.speacialfs</span></tt>. It is important to note
that the altenation keys (ie 1,2,3,4) are specified based on the other each altenation appears in the <cite>alt</cite> or <cite>opt</cite>
structure. The empty feature structure in the converted <cite>opt</cite> feature always appears last in the list
of alternations.</p>
<p>Another possible special value of the converted feature structure is the relative or absolute <cite>link</cite>.
The links may appear as a value of any feature key. The link value is enclosed in <tt class="docutils literal"><span class="pre">{}</span></tt>. During parsing,
the links are converted into Python objects through the <tt class="docutils literal"><span class="pre">nltk.fuf.link.ReentranceLink</span></tt> class.  Looking
at the converted feature structure below one of the links is found at <tt class="docutils literal"><span class="pre">alt_top['2']['n']['number']</span></tt> key.
Another link is located at <tt class="docutils literal"><span class="pre">alt_top['1']['verb']['number']</span></tt>. The link syntax and resolution is discussed later.</p>
<pre class="literal-block">
[           [     [ cat     = 's'                        ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ goal    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [ 1 = [ pattern = (prot, verb, goal)         ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ prot    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ verb    = [ cat    = 'vp'          ] ]            ] ]
[           [     [           [ number = {prot number} ] ]            ] ]
[           [                                                         ] ]
[           [     [       [ 1 = [ pattern = (n)   ]               ] ] ] ]
[           [     [       [     [ proper  = 'yes' ]               ] ] ] ]
[           [     [       [                                       ] ] ] ]
[           [     [ alt = [     [ det     = [ cat = 'article' ] ] ] ] ] ]
[           [     [       [     [           [ lex = 'the'     ] ] ] ] ] ]
[           [     [       [ 2 = [                               ] ] ] ] ]
[ alt_top = [ 2 = [       [     [ pattern = (det, n)            ] ] ] ] ]
[           [     [       [     [ proper  = 'no'                ] ] ] ] ]
[           [     [                                                 ] ] ]
[           [     [ cat = 'np'                                      ] ] ]
[           [     [                                                 ] ] ]
[           [     [ n   = [ cat    = 'noun'     ]                   ] ] ]
[           [     [       [ number = {^^number} ]                   ] ] ]
[           [                                                         ] ]
[           [     [ cat     = 'vp'             ]                      ] ]
[           [ 3 = [ pattern = (v)              ]                      ] ]
[           [     [                            ]                      ] ]
[           [     [ v       = [ cat = 'verb' ] ]                      ] ]
[           [                                                         ] ]
[           [ 4 = [ cat = 'noun' ]                                    ] ]
[           [                                                         ] ]
[           [ 5 = [ cat = 'verb' ]                                    ] ]
[           [                                                         ] ]
[           [ 6 = [ cat = 'article' ]                                 ] ]
</pre>
<p>Finally, when the input feature structure and the grammar have been converted, we can proceed to
their unification.</p>
</div>
<div class="section">
<h2><a id="fuf-py-or-towards-a-result" name="fuf-py-or-towards-a-result">fuf.py or Towards a Result</a></h2>
<div class="section">
<h3><a id="preprocessing" name="preprocessing">Preprocessing</a></h3>
<p>Unification is perfomed by the <tt class="docutils literal"><span class="pre">nltk.fuf.fuf.Unifier</span></tt> class. Before the unfication can start
some housekeeping must be done. Currently, the housekeeping revolves around processing the <cite>alt</cite>
features. Thus, before the unification start the code goes through all the possible alternations
in the grammar and creates a list of those paths. This is done with the <tt class="docutils literal"><span class="pre">nltk.fuf.fuf.GrammarPathResolver</span></tt>.
The result of the resolution is a a list of all possible feature stuctures generated through the alternations.
The original LISP FUF does not do this, rather it just picks up one <cite>alt</cite> path after another and tries to unify
the alternation with the input. This is clearly not the optimal solution as the size of the returned list
grows exponentially based on the number of <cite>alt</cite> features within the grammar. This is fertile ground
for improvements.</p>
</div>
<div class="section">
<h3><a id="types-and-their-use-during-unification" name="types-and-their-use-during-unification">Types and their use during unification</a></h3>
<p>Once the alt paths have been generated, the next step is a check for feature value types.
Feature value type handling is done through the <tt class="docutils literal"><span class="pre">nltk.fuf.fstypes</span></tt> module. The two classes contained
within the module are:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">FeatureValueTypeTable</span></tt>
The type table does all the maintenace of the value types. For a better discussion on feature value types
as they are defined in FUF please refer to the the FUF Manual (v5.2). The example below shows the
definition of several types. The syntax means that <cite>finite</cite> and <cite>non-finite</cite> are specializations
of the <cite>mood</cite>.</p>
<p>In <tt class="docutils literal"><span class="pre">FeatureValueTypeTable</span></tt> these relationships are stored within a <tt class="docutils literal"><span class="pre">dict</span></tt> object.</p>
<pre class="literal-block">
(define-feature-type mood (finite non-finite))
(define-feature-type finite (declarative interrogative bound relative))
(define-feature-type non-finite (imperative present-participle infinitive))
(define-feature-type interrogative (yes-no wh))
</pre>
<p>Using the <tt class="docutils literal"><span class="pre">tests/types.fuf</span></tt> file the result type table is this (the same result can be seen by running
<tt class="docutils literal"><span class="pre">python</span> <span class="pre">fstypes.py</span></tt>):</p>
<pre class="literal-block">
relative &lt;--- ['simple-relative', 'embedded-relative', 'be-deleted-relative', 'wh-nominal-relative', 'wh-ever-nominal-relative']
mood &lt;--- ['finite', 'non-finite']
non-finite &lt;--- ['imperative', 'present-participle', 'infinitive']
deontic-modality &lt;--- ['duty', 'authorization']
pronp &lt;--- ['personal-pronoun', 'question-pronoun', 'quantified-pronoun', 'demonstrative-pronoun']
det &lt;--- ['possessive-det', 'demonstrative-det', 'regular-det']
interrogative &lt;--- ['yes-no', 'wh']
process-type &lt;--- ['action', 'mental', 'attributive', 'equative']
np &lt;--- ['pronp', 'common', 'proper']
finite &lt;--- ['declarative', 'interrogative', 'bound', 'relative']
possessive-det &lt;--- ['np']
modality &lt;--- ['epistemic-modality', 'deontic-modality']
epistemic-modality &lt;--- ['fact', 'inference', 'possible']
</pre>
<p>We can use the <tt class="docutils literal"><span class="pre">FeatureTypeTable</span></tt> to check for subsumption. Working with the above table, we can do this by:</p>
<pre class="literal-block">
&gt;&gt;&gt; type_table.subsume('np', 'common')
&gt;&gt;&gt; # or
&gt;&gt;&gt; types_table.subsume('mood', 'imperative')
</pre>
<p>Both of the function calls to <tt class="docutils literal"><span class="pre">subsume</span></tt> on this table return <tt class="docutils literal"><span class="pre">True</span></tt>. During the unfication
the unifier off-loads the unification of typed features to the <tt class="docutils literal"><span class="pre">TypeFeatureValue</span></tt> class.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">TypedFeatureValue</span></tt></p>
<p>This class is used to represent the value within a feature structure. If the type table is present
with within the grammar file that is undergoing unification. The <tt class="docutils literal"><span class="pre">TypedFeatureValue</span></tt> is a subclass
of the <tt class="docutils literal"><span class="pre">CustomFeatureValue</span></tt> class defined <tt class="docutils literal"><span class="pre">nltk.featstruct</span></tt>. The <tt class="docutils literal"><span class="pre">CustomeFeatureValue</span></tt> allows
us to defined special unification on the value that are instances of this class.</p>
</li>
</ul>
<p>As in the case with the <cite>alt</cite> unpacking, before the grammar can be unified with the input feature
structure, feature values which are defined in the type table have to be instantiated in with in the grammar.
This work is performed by the <tt class="docutils literal"><span class="pre">fstypes.assign_types</span></tt> function. It traverses the given feature structure
and replaces the primitive values with instances of <tt class="docutils literal"><span class="pre">TypedFeatureValue</span></tt>.</p>
</div>
<div class="section">
<h3><a id="unification" name="unification">Unification</a></h3>
<p>Once all of housekeeping tasks are finished we can proceed to the actual unfication of the input and grammar
feature structures. The process of unification is defined in the <tt class="docutils literal"><span class="pre">nltk.fuf.fuf.Unifier</span></tt> class and more
specifically the <tt class="docutils literal"><span class="pre">unify</span></tt> method of the class.</p>
<p>The unifier attempts to unify one of the alternations from the alternations list generated by <tt class="docutils literal"><span class="pre">GrammarPathResolver</span></tt>
with the input. If all of the attempts to unify with the input fail then unification has failed. If one of
the attepts succeeds, the resultant feature structure must be checked for relative or absolute <cite>links</cite>.</p>
<div class="section">
<h4><a id="relative-and-absolute-links" name="relative-and-absolute-links">Relative and Absolute Links</a></h4>
<p>As mentioned previously, the class that represents either the relative or the absolute link in <tt class="docutils literal"><span class="pre">nltk.fuf</span></tt>
is <tt class="docutils literal"><span class="pre">nltk.fuf.link.ReentraceLink</span></tt>. When viewing a human-readable version of a feature strucuture they
can be identifed as feature values that are enclosed in <tt class="docutils literal"><span class="pre">{}</span></tt>. There are two types of links <cite>relative</cite> and
<cite>absolute</cite>. Relative links are have <tt class="docutils literal"><span class="pre">^</span></tt> following the <tt class="docutils literal"><span class="pre">{</span></tt> and absolute links have a feature key
following the <tt class="docutils literal"><span class="pre">{</span></tt>. For example, <tt class="docutils literal"><span class="pre">number</span> <span class="pre">=</span> <span class="pre">{^^number}</span></tt> is an relative link, whereas  <tt class="docutils literal"><span class="pre">number</span> <span class="pre">=</span> <span class="pre">{prot</span> <span class="pre">number}</span></tt>
is a absolute link. The <tt class="docutils literal"><span class="pre">^</span></tt> refers to the feature structure that has within it <tt class="docutils literal"><span class="pre">number</span> <span class="pre">=</span> <span class="pre">{^^number}</span></tt>.
The more <tt class="docutils literal"><span class="pre">^</span></tt> character there are the further the link goes up the structure. In absolute links,
the contents of <tt class="docutils literal"><span class="pre">{}</span></tt> define a path from the root feature structure to the the value they are pointing to.
There is no change here form the relative or absolute links as they used in the LISP FUF.</p>
<p>Link resolution is performed by the <tt class="docutils literal"><span class="pre">nltk.fuf.link.LinkResolver</span></tt> class, and the <tt class="docutils literal"><span class="pre">resolve</span></tt> method in particular.
This class is capable of handling both types of links. It is worth noting that the <tt class="docutils literal"><span class="pre">resolve</span></tt> method
will try to find the value of the link whether it is another feature structure or a primitive value. However,
if the value cannot be the link will be repaced with <tt class="docutils literal"><span class="pre">nltk.sem.Variable</span></tt>. Counts of the variables are done
during the lifetime of the <tt class="docutils literal"><span class="pre">LinkResolver</span></tt> object, thus they do not clash. If the value of the link is
a variable the varialbe will be copied. If the value of the link is another link, the resolver will attempt to
resolve the newly found link first and then copy the value to the link that it encountered first.</p>
</div>
</div>
<div class="section">
<h3><a id="unification-continued" name="unification-continued">Unification Continued</a></h3>
<p>Once the link resolution has been performed on the result of the unification, the unifier goes
through the sub-features of the result and attepts to unify the sub-features with the features
that represent grammar paths. Only those features which are considered to be <cite>constituents</cite> are
unified. A <cite>constituent</cite> feature is one that either contains a <cite>cat</cite> feature or is mentioned in
the <cite>pattern</cite> value or contains a <cite>lex</cite> feature or is specifically mentioned in the <cite>cset</cite> feature
value. Attemping to unfify features that are not constituents may result in infinite recursion.</p>
<p>The overall process of unification is illustrated in the example below (note that this exaple does not use the
feature types):</p>
<pre class="literal-block">
&gt;&gt;&gt; itext, gtext = open('tests/uni.fuf').readlines()
# set up the input structure
&gt;&gt;&gt; fsinput = fuf_to_featstruct(itext)
&gt;&gt;&gt; print fsinput
[ cat  = 's'                      ]
[                                 ]
[ goal = [ n = [ lex = 'mary' ] ] ]
[                                 ]
[ prot = [ n = [ lex = 'john' ] ] ]
[                                 ]
[ verb = [ v = [ lex = 'link' ] ] ]
# set up the grammar structure
&gt;&gt;&gt; fsgrammar = fuf_to_featstruct(gtext)
&gt;&gt;&gt; print fsgrammar
[           [     [ cat     = 's'                        ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ goal    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [ 1 = [ pattern = (prot, verb, goal)         ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ prot    = [ cat = 'np' ]             ]            ] ]
[           [     [                                      ]            ] ]
[           [     [ verb    = [ cat    = 'vp'          ] ]            ] ]
[           [     [           [ number = {prot number} ] ]            ] ]
[           [                                                         ] ]
[           [     [       [ 1 = [ pattern = (n)   ]               ] ] ] ]
[           [     [       [     [ proper  = 'yes' ]               ] ] ] ]
[           [     [       [                                       ] ] ] ]
[           [     [ alt = [     [ det     = [ cat = 'article' ] ] ] ] ] ]
[           [     [       [     [           [ lex = 'the'     ] ] ] ] ] ]
[           [     [       [ 2 = [                               ] ] ] ] ]
[ alt_top = [ 2 = [       [     [ pattern = (det, n)            ] ] ] ] ]
[           [     [       [     [ proper  = 'no'                ] ] ] ] ]
[           [     [                                                 ] ] ]
[           [     [ cat = 'np'                                      ] ] ]
[           [     [                                                 ] ] ]
[           [     [ n   = [ cat    = 'noun'     ]                   ] ] ]
[           [     [       [ number = {^^number} ]                   ] ] ]
[           [                                                         ] ]
[           [     [ cat     = 'vp'             ]                      ] ]
[           [ 3 = [ pattern = (v)              ]                      ] ]
[           [     [                            ]                      ] ]
[           [     [ v       = [ cat = 'verb' ] ]                      ] ]
[           [                                                         ] ]
[           [ 4 = [ cat = 'noun' ]                                    ] ]
[           [                                                         ] ]
[           [ 5 = [ cat = 'verb' ]                                    ] ]
[           [                                                         ] ]
[           [ 6 = [ cat = 'article' ]                                 ] ]
# unify the input and the grammar
&gt;&gt;&gt; fuf = Unifier(fsinput, fsgrammar)
&gt;&gt;&gt; result = fuf.unify()
# show the result
&gt;&gt;&gt; print result
[ cat     = 's'                               ]
[                                             ]
[           [ cat     = 'np'                ] ]
[           [                               ] ]
[           [           [ cat    = 'noun' ] ] ]
[           [ n       = [ lex    = 'mary' ] ] ]
[ goal    = [           [ number = ?x2    ] ] ]
[           [                               ] ]
[           [ number  = ?x2                 ] ]
[           [ pattern = (n)                 ] ]
[           [ proper  = 'yes'               ] ]
[                                             ]
[ pattern = (prot, verb, goal)                ]
[                                             ]
[           [ cat     = 'np'                ] ]
[           [                               ] ]
[           [           [ cat    = 'noun' ] ] ]
[           [ n       = [ lex    = 'john' ] ] ]
[ prot    = [           [ number = ?x1    ] ] ]
[           [                               ] ]
[           [ number  = ?x1                 ] ]
[           [ pattern = (n)                 ] ]
[           [ proper  = 'yes'               ] ]
[                                             ]
[           [ cat     = 'vp'             ]    ]
[           [ number  = ?x1              ]    ]
[ verb    = [ pattern = (v)              ]    ]
[           [                            ]    ]
[           [ v       = [ cat = 'verb' ] ]    ]
[           [           [ lex = 'link' ] ]    ]
</pre>
<p>Having obtained the result of unification we can proceed to linerarization of the output in order to generate
the final text output.</p>
</div>
</div>
<div class="section">
<h2><a id="linearizer-py-or-reaching-for-the-final-output" name="linearizer-py-or-reaching-for-the-final-output">linearizer.py or Reaching for the Final Output</a></h2>
<p>The linearization of the output produces the final output. The code for this is in <tt class="docutils literal"><span class="pre">nltk.fuf.linearizer</span></tt>,
specifically the <tt class="docutils literal"><span class="pre">linearize</span></tt> function.
The process starts by selecting the top level <cite>pattern</cite> feature value. The <cite>pattern</cite> features
spread through out the unification result define the order of the text. For example, in the structure
below:</p>
<pre class="literal-block">
[ cat     = 's'                               ]
[                                             ]
[           [ cat     = 'np'                ] ]
[           [                               ] ]
[           [           [ cat    = 'noun' ] ] ]
[           [ n       = [ lex    = 'mary' ] ] ]
[ goal    = [           [ number = ?x2    ] ] ]
[           [                               ] ]
[           [ number  = ?x2                 ] ]
[           [ pattern = (n)                 ] ]
[           [ proper  = 'yes'               ] ]
[                                             ]
[ pattern = (prot, verb, goal)                ]
[                                             ]
[           [ cat     = 'np'                ] ]
[           [                               ] ]
[           [           [ cat    = 'noun' ] ] ]
[           [ n       = [ lex    = 'john' ] ] ]
[ prot    = [           [ number = ?x1    ] ] ]
[           [                               ] ]
[           [ number  = ?x1                 ] ]
[           [ pattern = (n)                 ] ]
[           [ proper  = 'yes'               ] ]
[                                             ]
[           [ cat     = 'vp'             ]    ]
[           [ number  = ?x1              ]    ]
[ verb    = [ pattern = (v)              ]    ]
[           [                            ]    ]
[           [ v       = [ cat = 'verb' ] ]    ]
[           [           [ lex = 'link' ] ]    ]
</pre>
<p>the top level <cite>pattern</cite> has the value <tt class="docutils literal"><span class="pre">(prot,</span> <span class="pre">verb,</span> <span class="pre">goal)</span></tt>. Thefore the order of linearization is <tt class="docutils literal"><span class="pre">prot</span></tt> feature
first, <tt class="docutils literal"><span class="pre">verb</span></tt> feature second, and finally the <tt class="docutils literal"><span class="pre">goal</span></tt> feature. Following this path the linearizer
looks for <cite>pattern</cite> values in the sub-features until it finds the <cite>lex</cite> feature. At this stage the
morphology must be applied. Once the morphology has been applied the result is returned and the generation
process is finished.</p>
<div class="section">
<h3><a id="morphology" name="morphology">Morphology</a></h3>
<p>The morpholgy module, <tt class="docutils literal"><span class="pre">nltk.fuf.morphology</span></tt> coupled with <tt class="docutils literal"><span class="pre">nltk.fuf.lexicon</span></tt>, is a direct port of the LISP FUF <tt class="docutils literal"><span class="pre">morphology.scm</span></tt> code. It is currently implemented
as a set of heurirstics. However, it has decent converage. The code is quite self-descriptive.</p>
</div>
</div>
<div class="section">
<h2><a id="further-research-work" name="further-research-work">Further Research/Work</a></h2>
<p>There are a number of improvements and features that can be made/added to the <tt class="docutils literal"><span class="pre">nltk.fuf</span></tt> library.</p>
<ul class="simple">
<li>the <cite>index</cite> sub-feature in the <cite>alt</cite> feature is largely ignored at the moment. In LISP FUF this is
used to control the size of the possible paths through grammar. While this is parsed at the moment
it is not used to help the unifier.</li>
<li>it should be possible to do the unification without unpacking all the <cite>alt</cite> paths through the grammar.
ie, expand a little bit and go from there.</li>
<li>changing the <cite>alt</cite> handling requires changes timing for the link resolution.</li>
<li>currently during parsing all the comments and tracing calls are removed. It would be nice
to be able to enable tracing all stages of processing.</li>
<li>there are utility functions defined in LISP FUF to controll backtracking. These should be implemented as well.</li>
</ul>
</div>
<div class="section">
<h2><a id="further-reading" name="further-reading">Further Reading</a></h2>
<ul class="simple">
<li>API documntation - <tt class="docutils literal"><span class="pre">nltk_contrib/fuf/doc/api.html</span></tt></li>
<li>Home of LISP FUF/SURGE - <a class="reference" href="http://www.cs.bgu.ac.il/surge/index.html">http://www.cs.bgu.ac.il/surge/index.html</a></li>
<li>Grammars with Feature Strutures - <a class="reference" href="http://nltk.org/doc/en/featgram.html">http://nltk.org/doc/en/featgram.html</a></li>
<li>NLTK Feature STructure Guide - <a class="reference" href="http://nltk.org/doc/guides/featstruct.html">http://nltk.org/doc/guides/featstruct.html</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>

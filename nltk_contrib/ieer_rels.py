# Natural Language Toolkit: Relation Extraction
#
# Copyright (C) 2005-2007 University of Edinburgh
# Author: Ewan Klein <ewan@inf.ed.ac.uk>
# URL: <http://nltk.sf.net>
# For license information, see LICENSE.TXT

"""
Code for extracting triples of the form C{(subj, filler, obj)} from the ieer corpus,
after the latter has been converted to chunk format.
C{sub} and C{obj} are pairs of Named Entities, and C{filler} is the string of words occuring between C{sub} and C{obj} (with no intervening NEs).
Subsequent processing can try to identify interesting relations expressed in 
C{filler}.
"""
from nltk import defaultdict
from nltk import parse, tag, Tree
from nltk.corpus import ieer, conll2002

from string import join
import re
from itertools import islice, ifilter

# Dictionary that associates corpora with NE classes
NE_CLASSES = {'ieer': ['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 
                    'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE'],
            'conll2002': ['LOC', 'PER', 'ORG'],
            'conll2002-ned': ['LOC', 'PER', 'ORG'],
            'conll2002-esp': ['LOC', 'PER', 'ORG']
                }

# Allow abbreviated class labels                   
short2long = dict(LOC = 'LOCATION', ORG = 'ORGANIZATION', PER = 'PERSON')
long2short = dict(LOCATION ='LOC', ORGANIZATION = 'ORG', PERSON = 'PER')


ieerdocs = []
for item in ieer.items:
    for iedict in ieer.parsed_docs(item):
        for key in ['headline', 'text']:
            try:
                ieerdocs.append(iedict[key])
            except ValueError:
                pass

CORPORA = {
    'ieer': ieerdocs,
    #'conll2002': (tree for tree in conll2002.ne_chunked()),
    'conll2002-ned': (tree for tree in conll2002.read('ned.train', 'chunked')),
    'conll2002-esp': (tree for tree in conll2002.read('esp.train', 'chunked'))
}
    
def _tuple2tag(item):
    if isinstance(item, tuple): 
        (token, tag) = item
        return "".join(token + "/" + str(tag))
    else: return item

def _expand(type):
    try:
        return short2long[type]
    except KeyError:
        return ''
    
def mk_pairs(trees):
    """
    Group a chunk structure into pairs of the form (list(str), L{Tree})
    
    In order to facilitate the construction of (L{Tree}, string, L{Tree}) triples, this
    first identifies pairs whose first member is a list (posssibly empty) of terminal
    strings, and whose second member is a L{Tree} of the form (NE_label, terminals).
    
    @param trees: a sequence of chunk trees
    @return: a generator of pairs
    """
    pair = [[], None]
    for tree in trees:
        for dtr in tree:
            if not isinstance(dtr, Tree):
                pair[0].append(dtr)
            else:
                # dtr is a Tree
                pair[1] = dtr
                #result.append(tuple(pair))
                pair = [[], None]
                yield pair


def mk_rtuples(pairs, window=5):
    """
    Converts the pairs generated by L{mk_pairs} into a tuple (subj, filler, obj).
    Additionally, a left and right context of length =< window are captured.
    
    @param pairs: a pair of list(str) and L{Tree}, as generated by 
    @param window: a threshold for the number of items to include in the left and right context
    @type window: C{int}
    @return: 'relation' dictionaries whose keys are 'lcon', 'subjclass', 'subjtext', 'filler', objclass', objtext', and 'rcon'
    @rtype: generator of C{defaultdict}
    """
    remaining = list(pairs)
    while len(remaining) > 2:
        rel = defaultdict(str)
        rel['lcon'] = join(remaining[0][0][-window:])
        rel['subjclass'] = remaining[0][1].node
        rel['subjtext'] = join(remaining[0][1].leaves())
        rel['filler'] = join(remaining[1][0])
        rel['objclass'] = remaining[1][1].node
        rel['objtext'] = join(remaining[1][1].leaves())
        rel['rcon'] = join(remaining[2][0][:window])
        remaining = remaining[1:]
        yield rel

def relextract(subjclass, objclass, corpus, pattern=None, window=10):
    """
    Filter the output of L{mk_rtuples} according to specified NE classes and a filler pattern.
    
    The target output are triples consisting of
      - a Named Entity (i.e subtree), called the 'subject' of the triple, 
      - a string of words (i.e. leaves), called the 'filler' of the triple,
      - another Named Entity, called the 'object' of the triple.
      
    To help in data analysis, we also identify left and right context,
    i.e., a few words of context immediately preceding / following the
    first / second Named Entity.
     
    Apart from the first and last, every Named Entity can occur as both the
    subject and the object of a triple.
    
    The parameters C{subjclass} and C{objclass} can be used to restrict the 
    Named Entities to particular types (any of 'LOCATION', 'ORGANIZATION', 
    'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE').

    @param subjclass: the class of the subject Named Entity.
    @type subjclass: C{string}
    @param objclass: the class of the object Named Entity.
    @type objclass: C{string}
    @param corpus: name of the corpus to take as input; possible values are 'ieer', 'conll2002-ned' and 'conll2002-esp'
    @type corpus: C{string}
    @param pattern: a regular expression for filtering the fillers of
    retrieved triples.
    @type pattern: C{SRE_Pattern}
    @param window: filters out fillers which exceed this threshold
    @type window: C{int}
    @return: see L{mk_tuples}
    @rtype: C{generator} of C{defaultdict}
    """
    try:
        trees = CORPORA[corpus]
    except KeyError:
        print "corpus not recognized: '%s'" % corpus
    if subjclass and subjclass not in NE_CLASSES[corpus]:
        if _expand(subjclass) in NE_CLASSES[corpus]:
            subjclass = _expand(subjclass)
        else:
            raise ValueError, "your value for the subject type has not been recognized: %s" % subjclass
    if objclass and objclass not in NE_CLASSES[corpus]:
        if _expand(objclass) in NE_CLASSES[corpus]:
            objclass = _expand(objclass)
        else:
            raise ValueError, "your value for the object type has not been recognized: %s" % objclass
    pairs = mk_pairs(trees)
    rtuples = mk_rtuples(pairs)
    relfilter = lambda x: (x['subjclass'] == subjclass and
                           len(x['filler'].split()) <= window and 
                           pattern.match(x['filler']) and
                           x['objclass'] == objclass)
        
    return list(ifilter(relfilter, rtuples))

        
def _shorten(type):
    try:
        return long2short[type]
    except KeyError:
        return type

#def _show(item, tags=None):
    #if isinstance(item, Tree):
        #label = _shorten(item.node)
        #try:
            #words = [word for (word, tag) in item.leaves()]
        #except ValueError:
            #words = item.leaves()
        #text = join(words)
        #return '[%s: %s]' % (label, text)
    #elif isinstance(item, list):
        #return join([_show(e) for e in item])
    #else:
        #if tags:
            #return item
        #else:
            #item = tag2tuple(item)
            #return item[0]

def show_raw_rtuple(rtuple, lcon=False, rcon=False):
    """
    Printy print the rtuples.
    """
    items = [_shorten(rtuple['subjclass']), rtuple['subjtext'], rtuple['filler'], _shorten(rtuple['objclass']), rtuple['objtext']]
    format = '[%s: %s] %s [%s: %s]'
    if lcon:
        items = [rtuple['lcon']] + items
        format = '...%s)' + format
    if rcon:
        items.append(rtuple['rcon'])
        format = format + '(%s...'
    printargs = tuple(items)
    return format % printargs

def show_rel(rel, relclass):
        rtuple = (rtuple[subjclass], rtuple[subjtext], relclass, rtuple[objclass], rtuple[objtext])
        return '[%s: %s] %s [%s: %s]' % rtuple

    
def demo():
    """
    A demonstration of two relations extracted by simple regexps:
       - in(ORG, LOC), and
      - has_role(PERS, ORG)
    """
    ############################################
    # Example of in(ORG, LOC)
    ############################################
    IN = re.compile(r'.*\bin\b(?!\b.+ing\b)')
    trace = 1
    print "in(ORG, LOC):"
    print "=" * 30
    #for t in islice(relextract('ORG', 'LOC', pattern = IN,trace=trace), 29, 39): 
    for rel in relextract('ORG', 'LOC', 'ieer', pattern = IN):
        print show_raw_rtuple(rel)
        print "-" * 10
    print
    
    ############################################
    # Example of has_role(PER, LOC)
    ############################################
    roles = """
    (.*(                   # assorted roles
    analyst|
    chair(wo)?man|
    commissioner|
    counsel|
    director|
    economist|
    editor|
    executive|         
    foreman|
    governor|
    head|
    lawyer|
    leader|
    librarian).*)|
    manager|
    partner|
    president|
    producer|
    professor|
    researcher|
    spokes(wo)?man|
    writer|
    ,\sof\sthe?\s*  # "X, of (the) Y"
    """
    ROLES = re.compile(roles, re.VERBOSE)

    print "has_role(PER, ORG):"
    print "=" * 30
    for rel in relextract('PER', 'ORG', 'ieer', pattern = ROLES):
        print show_raw_rtuple(rel, rcon=True)
    print
    
    ##############################################
    ### Show what's in the IEER Headlines
    ##############################################
    
    #print "NER in Headlines"
    #print "=" * 30
 
    #for d in ieer.dictionary():
        #tree = d['headline']
        #for r in ne_fillers(tree):
            #print show_tuple(r[:-1])
    #print
        
    #############################################
    ## Dutch CONLL2002: take_on_role(PER, ORG
    #############################################
    
    #vnv = """
    #(
    #is/V|
    #was/V|
    #werd/V|
    #wordt/V
    #)
    #.*
    #van/Prep
    #"""
    #VAN = re.compile(vnv, re.VERBOSE)
     
    #print "van(PER, ORG):"
    #print "=" * 30
    #for rel in relextract('PER', 'ORG', 'conll2002-ned', pattern = VAN): 
        #print show_raw_tuple(rel)
    #print
    
    #############################################
    ## Spanish CONLL2002: (PER, ORG)
    #############################################
    
    #de = """
    #.*
    #(
    #de/SP|
    #del/SP
    #)
    #"""
    #DE = re.compile(de, re.VERBOSE)
     
    #print "de(ORG, LOC):"
    #print "=" * 30
    #for r in islice(relextract('ORG', 'LOC', corpus='conll2002-esp', pattern = DE), 10): 
        #print show_tuple(r)
    #print
    

if __name__ == '__main__':
    demo()


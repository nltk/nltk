# Natural Language Toolkit: Relation Extraction
#
# Copyright (C) 2005-2007 University of Edinburgh
# Author: Ewan Klein <ewan@inf.ed.ac.uk>
# URL: <http://nltk.sf.net>
# For license information, see LICENSE.TXT

"""
Code for extracting triples of the form C{(subj, filler, obj)} from the ieer corpus,
after the latter has been converted to chunk format.
C{sub} and C{obj} are pairs of Named Entities, and C{filler} is the string of words occuring between C{sub} and C{obj} (with no intervening NEs).
Subsequent processing can try to identify interesting relations expressed in 
C{filler}.
"""

from nltk import defaultdict
from nltk import parse, tag, Tree
from nltk.corpus import ieer, conll2002

from string import join
import re
from itertools import ifilter

# Dictionary that associates corpora with NE classes
NE_CLASSES = {'ieer': ['LOCATION', 'ORGANIZATION', 'PERSON', 'DURATION', 
                    'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE'],
            'conll2002': ['LOC', 'PER', 'ORG'],
            'conll2002-ned': ['LOC', 'PER', 'ORG'],
            'conll2002-esp': ['LOC', 'PER', 'ORG']
                }

# Allow abbreviated class labels                   
short2long = dict(LOC = 'LOCATION', ORG = 'ORGANIZATION', PER = 'PERSON')
long2short = dict(LOCATION ='LOC', ORGANIZATION = 'ORG', PERSON = 'PER')


def _tuple2tag(item):
    if isinstance(item, tuple): 
        (token, tag) = item
        return "".join(token + "/" + str(tag))
    else: return item

def _expand(type):
    try:
        return short2long[type]
    except KeyError:
        return ''
    
def mk_pairs(tree):
    """
    Group a chunk structure into pairs of the form (list(str), L{Tree})
    
    In order to facilitate the construction of (L{Tree}, string, L{Tree}) triples, this
    first identifies pairs whose first member is a list (possibly empty) of terminal
    strings, and whose second member is a L{Tree} of the form (NE_label, terminals).
    
    @param tree: a chunk tree
    @return: a list of pairs (list(C{str}), L{Tree})
    """

    pairs = []
    pair = [[], None]
    
    for dtr in tree:
        if not isinstance(dtr, Tree):
            pair[0].append(dtr)
        else:
            # dtr is a Tree
            pair[1] = dtr
            pairs.append(pair)
            pair = [[], None]
    return pairs


def mk_rtuples(pairs, window=5, trace=0):
    """
    Converts the pairs generated by L{mk_pairs} into a tuple (subj, filler, obj).
    Additionally, a left and right context of length =< window are captured.
    
    @param pairs: a pair of list(str) and L{Tree}, as generated by 
    @param window: a threshold for the number of items to include in the left and right context
    @type window: C{int}
    @return: 'relation' dictionaries whose keys are 'lcon', 'subjclass', 'subjtext', 'filler', objclass', objtext', and 'rcon'
    @rtype: list of C{defaultdict}
    """
    result = []
    while len(pairs) > 2:
        rel = defaultdict(str)
        rel['lcon'] = join(pairs[0][0][-window:])
        rel['subjclass'] = pairs[0][1].node
        rel['subjtext'] = join(pairs[0][1].leaves())
        rel['filler'] = join(pairs[1][0])
        rel['objclass'] = pairs[1][1].node
        rel['objtext'] = join(pairs[1][1].leaves())
        rel['rcon'] = join(pairs[2][0][:window])
        if trace:
            print "(rel(%s, %s)" % (rel['subjclass'], rel['objclass'])
        result.append(rel)
        pairs = pairs[1:]
    return result

def relextract(subjclass, objclass, doc, corpus='ieer', pattern=None, window=10):
    """
    Filter the output of L{mk_rtuples} according to specified NE classes and a filler pattern.
    
    The target output are triples consisting of
      - a Named Entity (i.e subtree), called the 'subject' of the triple, 
      - a string of words (i.e. leaves), called the 'filler' of the triple,
      - another Named Entity, called the 'object' of the triple.
      
    To help in data analysis, we also identify left and right context,
    i.e., a few words of context immediately preceding / following the
    first / second Named Entity.
     
    Apart from the first and last, every Named Entity can occur as both the
    subject and the object of a triple.
    
    The parameters C{subjclass} and C{objclass} can be used to restrict the 
    Named Entities to particular types (any of 'LOCATION', 'ORGANIZATION', 
    'PERSON', 'DURATION', 'DATE', 'CARDINAL', 'PERCENT', 'MONEY', 'MEASURE').

    @param subjclass: the class of the subject Named Entity.
    @type subjclass: C{string}
    @param objclass: the class of the object Named Entity.
    @type objclass: C{string}
    @param doc: input document
    @type doc: L{ieer} document or a list of chunk trees
    @param corpus: name of the corpus to take as input; possible values are 'ieer', 'conll2002-ned' and 'conll2002-esp'
    @type corpus: C{string}
    @param pattern: a regular expression for filtering the fillers of
    retrieved triples.
    @type pattern: C{SRE_Pattern}
    @param window: filters out fillers which exceed this threshold
    @type window: C{int}
    @return: see L{mk_tuples}
    @rtype: C{generator} of C{defaultdict}
    """
    
    if subjclass and subjclass not in NE_CLASSES[corpus]:
        if _expand(subjclass) in NE_CLASSES[corpus]:
            subjclass = _expand(subjclass)
        else:
            raise ValueError, "your value for the subject type has not been recognized: %s" % subjclass
    if objclass and objclass not in NE_CLASSES[corpus]:
        if _expand(objclass) in NE_CLASSES[corpus]:
            objclass = _expand(objclass)
        else:
            raise ValueError, "your value for the object type has not been recognized: %s" % objclass
    
 
    pairs = mk_pairs(doc.text) + mk_pairs(doc.headline)
            
    rtuples = mk_rtuples(pairs)
    relfilter = lambda x: (x['subjclass'] == subjclass and
                           len(x['filler'].split()) <= window and 
                           pattern.match(x['filler']) and
                           x['objclass'] == objclass)
        
    return list(ifilter(relfilter, rtuples))

        
def _shorten(type):
    try:
        return long2short[type]
    except KeyError:
        return type

#def _show(item, tags=None):
    #if isinvstance(item, Tree):
        #label = _shorten(item.node)
        #try:
            #words = [word for (word, tag) in item.leaves()]
        #except ValueError:
            #words = item.leaves()
        #text = join(words)
        #return '[%s: %s]' % (label, text)
    #elif isinstance(item, list):
        #return join([_show(e) for e in item])
    #else:
        #if tags:
            #return item
        #else:
            #item = tag2tuple(item)
            #return item[0]

def show_raw_rtuple(rtuple, lcon=False, rcon=False):
    """
    Pretty print the rtuples.
    """
    items = [_shorten(rtuple['subjclass']), rtuple['subjtext'], rtuple['filler'], _shorten(rtuple['objclass']), rtuple['objtext']]
    format = '[%s: %s] %s [%s: %s]'
    if lcon:
        items = [rtuple['lcon']] + items
        format = '...%s)' + format
    if rcon:
        items.append(rtuple['rcon'])
        format = format + '(%s...'
    printargs = tuple(items)
    return format % printargs

def show_rel(rel, relclass):
        rtuple = (rtuple[subjclass], rtuple[subjtext], relclass, rtuple[objclass], rtuple[objtext])
        return '[%s: %s] %s [%s: %s]' % rtuple


############################################
# Example of in(ORG, LOC)
############################################
def in_demo(trace=0):
    """
    A demonstration of two relations extracted by simple regexps:
       - in(ORG, LOC), and
      - has_role(PERS, ORG)
    """

    IN = re.compile(r'.*\bin\b(?!\b.+ing\b)')

    print "in(ORG, LOC):"
    print "=" * 30

    for item in ieer.items:
        for doc in ieer.parsed_docs(item):
            if trace:
                print doc.docno
                print "=" * 15
            for rel in relextract('ORG', 'LOC', doc, pattern = IN):
                count += 1
                print show_raw_rtuple(rel)



############################################
# Example of has_role(PER, LOC)
############################################
    
def roles_demo(trace=0):
    roles = """
    (.*(                   # assorted roles
    analyst|
    chair(wo)?man|
    commissioner|
    counsel|
    director|
    economist|
    editor|
    executive|         
    foreman|
    governor|
    head|
    lawyer|
    leader|
    librarian).*)|
    manager|
    partner|
    president|
    producer|
    professor|
    researcher|
    spokes(wo)?man|
    writer|
    ,\sof\sthe?\s*  # "X, of (the) Y"
    """
    ROLES = re.compile(roles, re.VERBOSE)

    print "has_role(PER, ORG):"
    print "=" * 30
    
    for item in ieer.items:
        for doc in ieer.parsed_docs(item):
            lcon = rcon = False
            if trace:
                print doc.docno
                print "=" * 15
                lcon = rcon = True
            for rel in relextract('PER', 'ORG', doc, pattern = ROLES):
                print show_raw_rtuple(rel, lcon=lcon, rcon=rcon)

    
    ##############################################
    ### Show what's in the IEER Headlines
    ##############################################
    
    #print "NER in Headlines"
    #print "=" * 30
 
    #for item in ieer.items:
           #for doc in ieer.parsed_docs(item):
               #tree = doc.headline
               #if isinstance(tree, Tree):
                   #print doc.docno, tree.pprint()
               #
                   #print join(tree.leaves())
               #else: 
                    #print tree

        
    #############################################
    ## Dutch CONLL2002: take_on_role(PER, ORG
    #############################################
    
    #vnv = """
    #(
    #is/V|
    #was/V|
    #werd/V|
    #wordt/V
    #)
    #.*
    #van/Prep
    #"""
    #VAN = re.compile(vnv, re.VERBOSE)
     
    #print "van(PER, ORG):"
    #print "=" * 30
    #for rel in relextract('PER', 'ORG', 'conll2002-ned', pattern = VAN): 
        #print show_raw_tuple(rel)
    #print
    
    #############################################
    ## Spanish CONLL2002: (PER, ORG)
    #############################################
    
    #de = """
    #.*
    #(
    #de/SP|
    #del/SP
    #)
    #"""
    #DE = re.compile(de, re.VERBOSE)
     
    #print "de(ORG, LOC):"
    #print "=" * 30
    #for r in islice(relextract('ORG', 'LOC', corpus='conll2002-esp', pattern = DE), 10): 
        #print show_tuple(r)
    #print
    

if __name__ == '__main__':
    in_demo(trace=0)
    roles_demo(trace=0)

#IN = re.compile(r'.*\bin\b(?!\b.+ing\b)')

#rels = [rel for item in ieer.items
        #for doc in ieer.parsed_docs(item)
        #for rel in relextract('ORG', 'LOC', doc, pattern = IN)]

#for r in rels[9:17]: print show_raw_rtuple(r)     



    

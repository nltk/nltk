#-----------------------------------------------------------------------------#
#
# Hole semantics grammar
#
# The semantic rules are adapted from BB1 which is
# Copyright (C) 2004 Patrick Blackburn & Johan Bos
# and licensed under the GPL.
#
#-----------------------------------------------------------------------------#

    # The start symbol
    #
%start S

    # Sentences
    # At the top level we complete the semantic representation with
    # a hole h0 and label l0.
    #
S[sem=<(\np vp.some h0 l0.(and (hole h0) (and (label l0) (np vp h0 l0))) ?np ?vp)>, num=?num] -> NP[sem=?np, num=?num] VP[sem=?vp, num=?num]

    # Noun phrases
    # The semantics of a NP take a verb, hole and label.
    #
NP[sem=<(?det ?n)>, num=?num] -> Det[sem=?det, num=?num] N[sem=?n, num=?num]
NP[sem=?pn] -> PN[sem=?pn]

    # Determiners
    # The determiners take a noun and return a function that takes a verb, hole
    # and label.
    #
Det[sem=<\n v h l.some h1 l1 l2 l3 x.(and (hole h1) (and (label l1) (and (label l2) (and (label l3) (and (: l2 (ALL  x l3)) (and (: l3 (IMP l1 h1)) (and (leq l h1) (and (leq l2 h) (and (n x h l1) (v x h l))))))))))>, num=?num] -> DetUniLex[num=?num]
Det[sem=<\n v h l.some h1 l1 l2 l3 x.(and (hole h1) (and (label l1) (and (label l2) (and (label l3) (and (: l2 (SOME x l3)) (and (: l3 (AND l1 h1)) (and (leq l h1) (and (leq l2 h) (and (n x h l1) (v x h l))))))))))>, num=?num] -> DetIndefLex[num=?num]
    # 'THE' quantifier is just made up.  In reality it'd be far more complex.
Det[sem=<\n v h l.some h1 l1 l2 l3 x.(and (hole h1) (and (label l1) (and (label l2) (and (label l3) (and (: l2 (THE  x l3)) (and (: l3 (AND l1 h1)) (and (leq l h1) (and (leq l2 h) (and (n x h l1) (v x h l))))))))))>] -> 'the'

    # Nouns can be modified by adjectives or have prepositional phrase or
    # relative clause attachments.
    #
N[sem=<(?adj ?n)>, num=?num] -> Adj[sem=?adj] N[sem=?n, num=?num]
N[sem=?n, num=?num] -> Noun[sem=?n, num=?num]
N[sem=<(?nmod ?n)>, num=?num] -> Noun[sem=?n, num=?num, human=?human] NMod[sem=?nmod, human=?human]

    # Nouns
    # Nouns take a variable v and assert that "v is a <insert noun>".
    # Nouns are applied to determiners which then results in a function that
    # takes a verb, so nouns do not take verbs directly.
    #
Noun[sem=<(\sym.\v h l.(and (: l (sym v)) (leq l h)) ?sym)>, num=?num, human=?human] -> NounLex[sym=?sym, num=?num, human=?human]

    # Proper nouns
    # The semantics of a NP take a verb, hole and label.
    #
PN[sem=<(\sym.\v h l.(v sym h l) ?sym)>, sym=?sym] -> PNLex[sym=?sym]

    # Adjectives
    # Adjectives take a predicate p and a variable x and assert that
    # "x is <insert adjective>" in addition to "p(x)".
    #
    # e.g. "x is RABID and (x is a CAT)" where "is a CAT" is p.
    #
Adj[sem=<(\sym.\p x h l.some l1 l2.(and (label l1) (and (label l2) (and (: l (AND l1 l2)) (and (: l2 (sym x)) (and (leq l h) (p x h l1)))))) ?sym)>] -> AdjLex[sym=?sym]

    # Noun modifier
    # There can be multiple prepositional phrases.
    #
NMod[sem=?pp] -> PP[sem=?pp]
NMod[sem=<(\pp nmod.\p.(pp (nmod p)) ?pp ?nmod)>, human=?human] -> PP[sem=?pp] NMod[sem=?nmod, human=?human]
NMod[sem=?rc, human=?human] -> RC[sem=?rc, human=?human]

    # Prepositional phrases
    #
PP[sem=<(?prep ?np)>] -> Prep[sem=?prep] NP[sem=?np]

    # Preposition
    # Takes a noun phrase z, a noun n and a variable x,
    # and asserts that "x is a n" (as usual) but also that
    # x is related to z (by the preposition).
    #
    # e.g. "x is a DOG and ... x is OF y"
    #
Prep[sem=<(\sym.\z n x h l.some h2 l2 l3.(and (hole h2) (and (label l2) (and (label l3) (and (: l (AND l2 h2)) (and (leq l h) (and (leq l3 h2) (and ((z \y h1 l1.(and (: l1 (sym y x)) (leq l1 h1))) h l3) (n x h l2)))))))) ?sym)>] -> PrepLex[sym=?sym]

    # Relative clauses
    #
RC[sem=<(?rp ?vp)>, human=?human] -> Relpro[sem=?rp, human=?human] VP[sem=?vp]

    # Relative pronoun
    # Take a verb v and a noun n and a variable x
    # and asserts that "x is a n" and "x does v".
    #
    # e.g. "x is a DOG and x GROWLS"
    #
Relpro[sem=<\v n x h l.some h1 l1 l2.(and (hole h1) (and (label l1) (and (label l2) (and (: l (AND l1 h1)) (and (leq l h) (and (leq l2 h1) (and (v x h l2) (n x h l1))))))))>, human=?human] -> RelproLex[human=?human]

    # Verb phrases
    # 
    # The num feature can be sg (singular) or pl (plural).
    # The inf feature can be inf (infinite forms) or fin (finite forms).
    #
VP[sem=<(?av ?vp)>, num=?num] -> AV[sem=?av, num=?num] VP[sem=?vp, inf=inf]
VP[sem=<(?cop ?np)>, inf=?inf, num=?num] -> Cop[sem=?cop, inf=?inf, num=?num] NP[sem=?np, num=?num]
VP[sem=?sem, inf=?inf, num=?num] -> IV[sem=?sem, inf=?inf, num=?num]
VP[sem=<(?tv ?np)>, inf=?inf, num=?num] -> TV[sem=?tv, inf=?inf, num=?num] NP[sem=?np]

    # Intransitive verbs
    # Takes a variable x and says that "x does <what>".
    #
IV[sem=<(\sym.\x h l.(and (: l (sym x)) (leq l h)) ?sym)>, inf=?inf, num=?num] -> IVLex[sym=?sym, inf=?inf, num=?num]

    # Transitive verbs
    # x and y are variables, z is the lambda expression of the object noun.
    #
TV[sem=<(\sym.\z x.(z \y h l.(and (: l (sym x y)) (leq l h))) ?sym)>, inf=?inf, num=?num] -> TVLex[sym=?sym, inf=?inf, num=?num]

    # Copula
    # The positive form is exactly the same as for transitive verbs.
    # The negative form introduces a NOT scope.
    #
Cop[sem=<\z x.(z \y h l.(and (: l (EQ y x)) (leq l h)))>, inf=?inf, num=?num] -> CopPosLex[inf=?inf, num=?num]
Cop[sem=<\z x.(z \y h l.some l1 h1.(and (label l1) (and (hole h1) (and (: l1 (NOT h1)) (and (: l (EQ y x)) (and (leq l h1) (leq l1 h)))))))>, inf=?inf, num=?num] -> CopNegLex[inf=?inf, num=?num]

    # Auxiliary verbs (does, doesn't)
    # The positive form is trivial.
    # The negative form introduces a NOT scope.
    #
AV[sem=<\v x h l.(v x h l)>, inf=?inf, num=?num] -> AVPosLex[inf=?inf, num=?num]
AV[sem=<\v x h l.some s n.(and (hole s) (and (label n) (and (: n (NOT s)) (and (leq n h) (and (leq l s) (v x h l))))))>, inf=?inf, num=?num] -> AVNegLex[inf=?inf, num=?num]

#-----------------------------------------------------------------------------#
# Lexicon.  Here we can add as much as we like.
#-----------------------------------------------------------------------------#

    # Universal quantification
    #
DetUniLex[num=sg] -> 'every'
DetUniLex[num=pl] -> 'all'

    # Existential quantification
    #
DetIndefLex -> 'some'
DetIndefLex[num=sg] -> 'a'
    # not sure about this
DetIndefLex[num=pl] ->

    # Nouns
    #
NounLex[sym=<BOXER>, num=sg, human=human] -> 'boxer'
NounLex[sym=<BOXER>, num=pl, human=human] -> 'boxers'
NounLex[sym=<DOG>, num=sg, human=animal] -> 'dog'
NounLex[sym=<DOG>, num=pl, human=animal] -> 'dogs'
NounLex[sym=<CAT>, num=sg, human=animal] -> 'cat'
NounLex[sym=<CAT>, num=pl, human=animal] -> 'cats'
NounLex[sym=<SHEEP>, human=animal] -> 'sheep'

    # Proper nouns
    #
PNLex[sym=<JOHN>] -> 'John'
PNLex[sym=<KIM>] -> 'Kim'

    # Adjectives
    #
AdjLex[sym=<BIG>] -> 'big'
AdjLex[sym=<RABID>] -> 'rabid'
AdjLex[sym=<WHITE>] -> 'white'

    # Prepositions
    #
PrepLex[sym=<IN>] -> 'in'
PrepLex[sym=<OF>] -> 'of'

    # Relative pronouns
    #
RelproLex[human=human] -> 'who'
RelproLex[human=animal] -> 'which'

    # Intransitive verbs
    #
IVLex[sym=<GROWL>, inf=inf, num=pl] -> 'growl'
IVLex[sym=<GROWL>, inf=fin, num=sg] -> 'growls'
IVLex[sym=<GROWL>, inf=fin, num=pl] -> 'growl'

    # Transitive verbs
    #
TVLex[sym=<BITE>, inf=inf, num=pl] -> 'bite'
TVLex[sym=<BITE>, inf=fin, num=sg] -> 'bites'
TVLex[sym=<BITE>, inf=fin, num=pl] -> 'bite'

    # Copula
    #
CopPosLex[inf=fin, num=sg] -> 'is'
CopPosLex[inf=fin, num=pl] -> 'are'
CopNegLex[inf=fin, num=sg] -> "isn't"
CopNegLex[inf=fin, num=pl] -> "aren't"

    # Auxiliary verbs
    #
AVPosLex[inf=fin, num=sg] -> 'does'
AVNegLex[inf=fin, num=sg] -> "doesn't"
AVPosLex[inf=fin, num=pl] -> 'do'
AVNegLex[inf=fin, num=pl] -> "don't"

#-----------------------------------------------------------------------------#
